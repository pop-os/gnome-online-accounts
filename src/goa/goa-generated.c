/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "goa-generated.h"

#include <string.h>
#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  guint use_gvariant : 1;
  guint emits_changed_signal : 1;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        {
          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
          gdouble da = g_value_get_double (a);
          gdouble db = g_value_get_double (b);
          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
        }
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Account
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaAccount
 * @title: GoaAccount
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Account D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Account ---- */

static const _ExtendedGDBusMethodInfo _goa_account_method_info_remove =
{
  {
    -1,
    (gchar *) "Remove",
    NULL,
    NULL,
    NULL
  },
  "handle-remove",
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_account_method_info_ensure_credentials_OUT_ARG_expires_in =
{
  {
    -1,
    (gchar *) "expires_in",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_account_method_info_ensure_credentials_OUT_ARG_pointers[] =
{
  &_goa_account_method_info_ensure_credentials_OUT_ARG_expires_in.parent_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_account_method_info_ensure_credentials =
{
  {
    -1,
    (gchar *) "EnsureCredentials",
    NULL,
    (GDBusArgInfo **) &_goa_account_method_info_ensure_credentials_OUT_ARG_pointers,
    NULL
  },
  "handle-ensure-credentials",
  FALSE
};

static const GDBusMethodInfo * const _goa_account_method_info_pointers[] =
{
  &_goa_account_method_info_remove.parent_struct,
  &_goa_account_method_info_ensure_credentials.parent_struct,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_provider_type =
{
  {
    -1,
    (gchar *) "ProviderType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "provider-type",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_provider_name =
{
  {
    -1,
    (gchar *) "ProviderName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "provider-name",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_provider_icon =
{
  {
    -1,
    (gchar *) "ProviderIcon",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "provider-icon",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_id =
{
  {
    -1,
    (gchar *) "Id",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "id",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_is_locked =
{
  {
    -1,
    (gchar *) "IsLocked",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "is-locked",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_is_temporary =
{
  {
    -1,
    (gchar *) "IsTemporary",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "is-temporary",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_attention_needed =
{
  {
    -1,
    (gchar *) "AttentionNeeded",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "attention-needed",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_identity =
{
  {
    -1,
    (gchar *) "Identity",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "identity",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_presentation_identity =
{
  {
    -1,
    (gchar *) "PresentationIdentity",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "presentation-identity",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_mail_disabled =
{
  {
    -1,
    (gchar *) "MailDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "mail-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_calendar_disabled =
{
  {
    -1,
    (gchar *) "CalendarDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "calendar-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_contacts_disabled =
{
  {
    -1,
    (gchar *) "ContactsDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "contacts-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_chat_disabled =
{
  {
    -1,
    (gchar *) "ChatDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "chat-disabled",
  FALSE,
  TRUE
};

static const GDBusAnnotationInfo _goa_account_property_documents_disabled_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _goa_account_property_documents_disabled_annotation_info_pointers[] =
{
  &_goa_account_property_documents_disabled_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_documents_disabled =
{
  {
    -1,
    (gchar *) "DocumentsDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_goa_account_property_documents_disabled_annotation_info_pointers
  },
  "documents-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_maps_disabled =
{
  {
    -1,
    (gchar *) "MapsDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "maps-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_music_disabled =
{
  {
    -1,
    (gchar *) "MusicDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "music-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_printers_disabled =
{
  {
    -1,
    (gchar *) "PrintersDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "printers-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_photos_disabled =
{
  {
    -1,
    (gchar *) "PhotosDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "photos-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_files_disabled =
{
  {
    -1,
    (gchar *) "FilesDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "files-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_ticketing_disabled =
{
  {
    -1,
    (gchar *) "TicketingDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ticketing-disabled",
  FALSE,
  TRUE
};

static const GDBusAnnotationInfo _goa_account_property_todo_disabled_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _goa_account_property_todo_disabled_annotation_info_pointers[] =
{
  &_goa_account_property_todo_disabled_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_todo_disabled =
{
  {
    -1,
    (gchar *) "TodoDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_goa_account_property_todo_disabled_annotation_info_pointers
  },
  "todo-disabled",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_account_property_info_read_later_disabled =
{
  {
    -1,
    (gchar *) "ReadLaterDisabled",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "read-later-disabled",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_account_property_info_pointers[] =
{
  &_goa_account_property_info_provider_type.parent_struct,
  &_goa_account_property_info_provider_name.parent_struct,
  &_goa_account_property_info_provider_icon.parent_struct,
  &_goa_account_property_info_id.parent_struct,
  &_goa_account_property_info_is_locked.parent_struct,
  &_goa_account_property_info_is_temporary.parent_struct,
  &_goa_account_property_info_attention_needed.parent_struct,
  &_goa_account_property_info_identity.parent_struct,
  &_goa_account_property_info_presentation_identity.parent_struct,
  &_goa_account_property_info_mail_disabled.parent_struct,
  &_goa_account_property_info_calendar_disabled.parent_struct,
  &_goa_account_property_info_contacts_disabled.parent_struct,
  &_goa_account_property_info_chat_disabled.parent_struct,
  &_goa_account_property_info_documents_disabled.parent_struct,
  &_goa_account_property_info_maps_disabled.parent_struct,
  &_goa_account_property_info_music_disabled.parent_struct,
  &_goa_account_property_info_printers_disabled.parent_struct,
  &_goa_account_property_info_photos_disabled.parent_struct,
  &_goa_account_property_info_files_disabled.parent_struct,
  &_goa_account_property_info_ticketing_disabled.parent_struct,
  &_goa_account_property_info_todo_disabled.parent_struct,
  &_goa_account_property_info_read_later_disabled.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_account_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Account",
    (GDBusMethodInfo **) &_goa_account_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_account_property_info_pointers,
    NULL
  },
  "account",
};


/**
 * goa_account_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_account_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct;
}

/**
 * goa_account_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaAccount interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_account_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "provider-type");
  g_object_class_override_property (klass, property_id_begin++, "provider-name");
  g_object_class_override_property (klass, property_id_begin++, "provider-icon");
  g_object_class_override_property (klass, property_id_begin++, "id");
  g_object_class_override_property (klass, property_id_begin++, "is-locked");
  g_object_class_override_property (klass, property_id_begin++, "is-temporary");
  g_object_class_override_property (klass, property_id_begin++, "attention-needed");
  g_object_class_override_property (klass, property_id_begin++, "identity");
  g_object_class_override_property (klass, property_id_begin++, "presentation-identity");
  g_object_class_override_property (klass, property_id_begin++, "mail-disabled");
  g_object_class_override_property (klass, property_id_begin++, "calendar-disabled");
  g_object_class_override_property (klass, property_id_begin++, "contacts-disabled");
  g_object_class_override_property (klass, property_id_begin++, "chat-disabled");
  g_object_class_override_property (klass, property_id_begin++, "documents-disabled");
  g_object_class_override_property (klass, property_id_begin++, "maps-disabled");
  g_object_class_override_property (klass, property_id_begin++, "music-disabled");
  g_object_class_override_property (klass, property_id_begin++, "printers-disabled");
  g_object_class_override_property (klass, property_id_begin++, "photos-disabled");
  g_object_class_override_property (klass, property_id_begin++, "files-disabled");
  g_object_class_override_property (klass, property_id_begin++, "ticketing-disabled");
  g_object_class_override_property (klass, property_id_begin++, "todo-disabled");
  g_object_class_override_property (klass, property_id_begin++, "read-later-disabled");
  return property_id_begin - 1;
}



/**
 * GoaAccount:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>.
 */

/**
 * GoaAccountIface:
 * @parent_iface: The parent interface.
 * @handle_ensure_credentials: Handler for the #GoaAccount::handle-ensure-credentials signal.
 * @handle_remove: Handler for the #GoaAccount::handle-remove signal.
 * @get_attention_needed: Getter for the #GoaAccount:attention-needed property.
 * @get_calendar_disabled: Getter for the #GoaAccount:calendar-disabled property.
 * @get_chat_disabled: Getter for the #GoaAccount:chat-disabled property.
 * @get_contacts_disabled: Getter for the #GoaAccount:contacts-disabled property.
 * @get_documents_disabled: Getter for the #GoaAccount:documents-disabled property.
 * @get_id: Getter for the #GoaAccount:id property.
 * @get_identity: Getter for the #GoaAccount:identity property.
 * @get_is_temporary: Getter for the #GoaAccount:is-temporary property.
 * @get_mail_disabled: Getter for the #GoaAccount:mail-disabled property.
 * @get_presentation_identity: Getter for the #GoaAccount:presentation-identity property.
 * @get_provider_icon: Getter for the #GoaAccount:provider-icon property.
 * @get_provider_name: Getter for the #GoaAccount:provider-name property.
 * @get_provider_type: Getter for the #GoaAccount:provider-type property.
 * @get_ticketing_disabled: Getter for the #GoaAccount:ticketing-disabled property.
 * @get_files_disabled: Getter for the #GoaAccount:files-disabled property.
 * @get_photos_disabled: Getter for the #GoaAccount:photos-disabled property.
 * @get_printers_disabled: Getter for the #GoaAccount:printers-disabled property.
 * @get_read_later_disabled: Getter for the #GoaAccount:read-later-disabled property.
 * @get_maps_disabled: Getter for the #GoaAccount:maps-disabled property.
 * @get_is_locked: Getter for the #GoaAccount:is-locked property.
 * @get_music_disabled: Getter for the #GoaAccount:music-disabled property.
 * @get_todo_disabled: Getter for the #GoaAccount:todo-disabled property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>.
 */

typedef GoaAccountIface GoaAccountInterface;
G_DEFINE_INTERFACE (GoaAccount, goa_account, G_TYPE_OBJECT)

static void
goa_account_default_init (GoaAccountIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaAccount::handle-remove:
   * @object: A #GoaAccount.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_account_complete_remove() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaAccountIface, handle_remove),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * GoaAccount::handle-ensure-credentials:
   * @object: A #GoaAccount.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_account_complete_ensure_credentials() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-ensure-credentials",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaAccountIface, handle_ensure_credentials),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaAccount:provider-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("provider-type", "ProviderType", "ProviderType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:provider-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("provider-name", "ProviderName", "ProviderName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:provider-icon:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("provider-icon", "ProviderIcon", "ProviderIcon", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:id:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("id", "Id", "Id", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:is-locked:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsLocked">"IsLocked"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.16.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("is-locked", "IsLocked", "IsLocked", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:is-temporary:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsTemporary">"IsTemporary"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("is-temporary", "IsTemporary", "IsTemporary", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:attention-needed:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.AttentionNeeded">"AttentionNeeded"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("attention-needed", "AttentionNeeded", "AttentionNeeded", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:identity:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("identity", "Identity", "Identity", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:presentation-identity:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("presentation-identity", "PresentationIdentity", "PresentationIdentity", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:mail-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MailDisabled">"MailDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("mail-disabled", "MailDisabled", "MailDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:calendar-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.CalendarDisabled">"CalendarDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("calendar-disabled", "CalendarDisabled", "CalendarDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:contacts-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ContactsDisabled">"ContactsDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("contacts-disabled", "ContactsDisabled", "ContactsDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:chat-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ChatDisabled">"ChatDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("chat-disabled", "ChatDisabled", "ChatDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:documents-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.DocumentsDisabled">"DocumentsDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Deprecated: The D-Bus property has been deprecated.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("documents-disabled", "DocumentsDisabled", "DocumentsDisabled", FALSE, G_PARAM_DEPRECATED | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:maps-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MapsDisabled">"MapsDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.14.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("maps-disabled", "MapsDisabled", "MapsDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:music-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MusicDisabled">"MusicDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.18.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("music-disabled", "MusicDisabled", "MusicDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:printers-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PrintersDisabled">"PrintersDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.12.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("printers-disabled", "PrintersDisabled", "PrintersDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:photos-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PhotosDisabled">"PhotosDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("photos-disabled", "PhotosDisabled", "PhotosDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:files-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.FilesDisabled">"FilesDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("files-disabled", "FilesDisabled", "FilesDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:ticketing-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TicketingDisabled">"TicketingDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("ticketing-disabled", "TicketingDisabled", "TicketingDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:todo-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TodoDisabled">"TodoDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.26.0
   *
   * Deprecated: The D-Bus property has been deprecated.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("todo-disabled", "TodoDisabled", "TodoDisabled", FALSE, G_PARAM_DEPRECATED | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaAccount:read-later-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ReadLaterDisabled">"ReadLaterDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Since: 3.12.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("read-later-disabled", "ReadLaterDisabled", "ReadLaterDisabled", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_account_get_provider_type: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_provider_type() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_provider_type (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_provider_type (object);
}

/**
 * goa_account_dup_provider_type: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_provider_type (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "provider-type", &value, NULL);
  return value;
}

/**
 * goa_account_set_provider_type: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderType">"ProviderType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_provider_type (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "provider-type", value, NULL);
}

/**
 * goa_account_get_provider_name: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_provider_name() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_provider_name (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_provider_name (object);
}

/**
 * goa_account_dup_provider_name: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_provider_name (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "provider-name", &value, NULL);
  return value;
}

/**
 * goa_account_set_provider_name: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderName">"ProviderName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_provider_name (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "provider-name", value, NULL);
}

/**
 * goa_account_get_provider_icon: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_provider_icon() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_provider_icon (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_provider_icon (object);
}

/**
 * goa_account_dup_provider_icon: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_provider_icon (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "provider-icon", &value, NULL);
  return value;
}

/**
 * goa_account_set_provider_icon: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ProviderIcon">"ProviderIcon"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_provider_icon (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "provider-icon", value, NULL);
}

/**
 * goa_account_get_id: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_id() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_id (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_id (object);
}

/**
 * goa_account_dup_id: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_id (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "id", &value, NULL);
  return value;
}

/**
 * goa_account_set_id: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Id">"Id"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_id (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "id", value, NULL);
}

/**
 * goa_account_get_is_locked: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsLocked">"IsLocked"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.16.0
 */
gboolean 
goa_account_get_is_locked (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_is_locked (object);
}

/**
 * goa_account_set_is_locked: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsLocked">"IsLocked"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.16.0
 */
void
goa_account_set_is_locked (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "is-locked", value, NULL);
}

/**
 * goa_account_get_is_temporary: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsTemporary">"IsTemporary"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_is_temporary (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_is_temporary (object);
}

/**
 * goa_account_set_is_temporary: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.IsTemporary">"IsTemporary"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_is_temporary (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "is-temporary", value, NULL);
}

/**
 * goa_account_get_attention_needed: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.AttentionNeeded">"AttentionNeeded"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_attention_needed (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_attention_needed (object);
}

/**
 * goa_account_set_attention_needed: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.AttentionNeeded">"AttentionNeeded"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_attention_needed (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "attention-needed", value, NULL);
}

/**
 * goa_account_get_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_identity() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_identity (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_identity (object);
}

/**
 * goa_account_dup_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_identity (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "identity", &value, NULL);
  return value;
}

/**
 * goa_account_set_identity: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.Identity">"Identity"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_identity (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "identity", value, NULL);
}

/**
 * goa_account_get_presentation_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_account_dup_presentation_identity() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_account_get_presentation_identity (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_presentation_identity (object);
}

/**
 * goa_account_dup_presentation_identity: (skip)
 * @object: A #GoaAccount.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_account_dup_presentation_identity (GoaAccount *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "presentation-identity", &value, NULL);
  return value;
}

/**
 * goa_account_set_presentation_identity: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PresentationIdentity">"PresentationIdentity"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_account_set_presentation_identity (GoaAccount *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "presentation-identity", value, NULL);
}

/**
 * goa_account_get_mail_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MailDisabled">"MailDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_mail_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_mail_disabled (object);
}

/**
 * goa_account_set_mail_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MailDisabled">"MailDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_mail_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "mail-disabled", value, NULL);
}

/**
 * goa_account_get_calendar_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.CalendarDisabled">"CalendarDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_calendar_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_calendar_disabled (object);
}

/**
 * goa_account_set_calendar_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.CalendarDisabled">"CalendarDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_calendar_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "calendar-disabled", value, NULL);
}

/**
 * goa_account_get_contacts_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ContactsDisabled">"ContactsDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_contacts_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_contacts_disabled (object);
}

/**
 * goa_account_set_contacts_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ContactsDisabled">"ContactsDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_contacts_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "contacts-disabled", value, NULL);
}

/**
 * goa_account_get_chat_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ChatDisabled">"ChatDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_account_get_chat_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_chat_disabled (object);
}

/**
 * goa_account_set_chat_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ChatDisabled">"ChatDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
goa_account_set_chat_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "chat-disabled", value, NULL);
}

/**
 * goa_account_get_documents_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.DocumentsDisabled">"DocumentsDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
gboolean 
goa_account_get_documents_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_documents_disabled (object);
}

/**
 * goa_account_set_documents_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.DocumentsDisabled">"DocumentsDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
void
goa_account_set_documents_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "documents-disabled", value, NULL);
}

/**
 * goa_account_get_maps_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MapsDisabled">"MapsDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.14.0
 */
gboolean 
goa_account_get_maps_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_maps_disabled (object);
}

/**
 * goa_account_set_maps_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MapsDisabled">"MapsDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.14.0
 */
void
goa_account_set_maps_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "maps-disabled", value, NULL);
}

/**
 * goa_account_get_music_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MusicDisabled">"MusicDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.18.0
 */
gboolean 
goa_account_get_music_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_music_disabled (object);
}

/**
 * goa_account_set_music_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.MusicDisabled">"MusicDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.18.0
 */
void
goa_account_set_music_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "music-disabled", value, NULL);
}

/**
 * goa_account_get_printers_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PrintersDisabled">"PrintersDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.12.0
 */
gboolean 
goa_account_get_printers_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_printers_disabled (object);
}

/**
 * goa_account_set_printers_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PrintersDisabled">"PrintersDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.12.0
 */
void
goa_account_set_printers_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "printers-disabled", value, NULL);
}

/**
 * goa_account_get_photos_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PhotosDisabled">"PhotosDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_account_get_photos_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_photos_disabled (object);
}

/**
 * goa_account_set_photos_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.PhotosDisabled">"PhotosDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.8.0
 */
void
goa_account_set_photos_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "photos-disabled", value, NULL);
}

/**
 * goa_account_get_files_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.FilesDisabled">"FilesDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_account_get_files_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_files_disabled (object);
}

/**
 * goa_account_set_files_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.FilesDisabled">"FilesDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.8.0
 */
void
goa_account_set_files_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "files-disabled", value, NULL);
}

/**
 * goa_account_get_ticketing_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TicketingDisabled">"TicketingDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.6.0
 */
gboolean 
goa_account_get_ticketing_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_ticketing_disabled (object);
}

/**
 * goa_account_set_ticketing_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TicketingDisabled">"TicketingDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.6.0
 */
void
goa_account_set_ticketing_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "ticketing-disabled", value, NULL);
}

/**
 * goa_account_get_todo_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TodoDisabled">"TodoDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
gboolean 
goa_account_get_todo_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_todo_disabled (object);
}

/**
 * goa_account_set_todo_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.TodoDisabled">"TodoDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
void
goa_account_set_todo_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "todo-disabled", value, NULL);
}

/**
 * goa_account_get_read_later_disabled: (skip)
 * @object: A #GoaAccount.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ReadLaterDisabled">"ReadLaterDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.12.0
 */
gboolean 
goa_account_get_read_later_disabled (GoaAccount *object)
{
  return GOA_ACCOUNT_GET_IFACE (object)->get_read_later_disabled (object);
}

/**
 * goa_account_set_read_later_disabled: (skip)
 * @object: A #GoaAccount.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Account.ReadLaterDisabled">"ReadLaterDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Since: 3.12.0
 */
void
goa_account_set_read_later_disabled (GoaAccount *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "read-later-disabled", value, NULL);
}

/**
 * goa_account_call_remove:
 * @proxy: A #GoaAccountProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_account_call_remove_finish() to get the result of the operation.
 *
 * See goa_account_call_remove_sync() for the synchronous, blocking version of this method.
 */
void
goa_account_call_remove (
    GoaAccount *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Remove",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_account_call_remove_finish:
 * @proxy: A #GoaAccountProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_call_remove().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_account_call_remove().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_remove_finish (
    GoaAccount *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_call_remove_sync:
 * @proxy: A #GoaAccountProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_account_call_remove() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_remove_sync (
    GoaAccount *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Remove",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_call_ensure_credentials:
 * @proxy: A #GoaAccountProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_account_call_ensure_credentials_finish() to get the result of the operation.
 *
 * See goa_account_call_ensure_credentials_sync() for the synchronous, blocking version of this method.
 */
void
goa_account_call_ensure_credentials (
    GoaAccount *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "EnsureCredentials",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_account_call_ensure_credentials_finish:
 * @proxy: A #GoaAccountProxy.
 * @out_expires_in: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_call_ensure_credentials().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_account_call_ensure_credentials().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_ensure_credentials_finish (
    GoaAccount *proxy,
    gint *out_expires_in,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_call_ensure_credentials_sync:
 * @proxy: A #GoaAccountProxy.
 * @out_expires_in: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_account_call_ensure_credentials() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_account_call_ensure_credentials_sync (
    GoaAccount *proxy,
    gint *out_expires_in,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "EnsureCredentials",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_account_complete_remove:
 * @object: A #GoaAccount.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.Remove">Remove()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_account_complete_remove (
    GoaAccount *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * goa_account_complete_ensure_credentials:
 * @object: A #GoaAccount.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @expires_in: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Account.EnsureCredentials">EnsureCredentials()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_account_complete_ensure_credentials (
    GoaAccount *object,
    GDBusMethodInvocation *invocation,
    gint expires_in)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   expires_in));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaAccountProxy:
 *
 * The #GoaAccountProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaAccountProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaAccountProxy.
 */

struct _GoaAccountProxyPrivate
{
  GData *qdata;
};

static void goa_account_proxy_iface_init (GoaAccountIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaAccountProxy, goa_account_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaAccountProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_ACCOUNT, goa_account_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaAccountProxy, goa_account_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_ACCOUNT, goa_account_proxy_iface_init))

#endif
static void
goa_account_proxy_finalize (GObject *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_account_proxy_parent_class)->finalize (object);
}

static void
goa_account_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 22);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_account_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_account_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Account: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_account_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 22);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_account_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Account", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_account_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_account_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_ACCOUNT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_ACCOUNT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_account_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_account_proxy_get_provider_type (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProviderType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_provider_name (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProviderName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_provider_icon (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProviderIcon");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_id (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Id");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_is_locked (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IsLocked");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_is_temporary (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IsTemporary");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_attention_needed (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AttentionNeeded");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_identity (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Identity");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_account_proxy_get_presentation_identity (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PresentationIdentity");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_mail_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "MailDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_calendar_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CalendarDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_contacts_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ContactsDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_chat_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ChatDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_documents_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DocumentsDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_maps_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "MapsDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_music_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "MusicDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_printers_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PrintersDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_photos_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PhotosDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_files_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FilesDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_ticketing_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "TicketingDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_todo_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "TodoDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_account_proxy_get_read_later_disabled (GoaAccount *object)
{
  GoaAccountProxy *proxy = GOA_ACCOUNT_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ReadLaterDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_account_proxy_init (GoaAccountProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_account_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_ACCOUNT_PROXY, GoaAccountProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_account_interface_info ());
}

static void
goa_account_proxy_class_init (GoaAccountProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_account_proxy_finalize;
  gobject_class->get_property = goa_account_proxy_get_property;
  gobject_class->set_property = goa_account_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_account_proxy_g_signal;
  proxy_class->g_properties_changed = goa_account_proxy_g_properties_changed;

  goa_account_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaAccountProxyPrivate));
#endif
}

static void
goa_account_proxy_iface_init (GoaAccountIface *iface)
{
  iface->get_provider_type = goa_account_proxy_get_provider_type;
  iface->get_provider_name = goa_account_proxy_get_provider_name;
  iface->get_provider_icon = goa_account_proxy_get_provider_icon;
  iface->get_id = goa_account_proxy_get_id;
  iface->get_is_locked = goa_account_proxy_get_is_locked;
  iface->get_is_temporary = goa_account_proxy_get_is_temporary;
  iface->get_attention_needed = goa_account_proxy_get_attention_needed;
  iface->get_identity = goa_account_proxy_get_identity;
  iface->get_presentation_identity = goa_account_proxy_get_presentation_identity;
  iface->get_mail_disabled = goa_account_proxy_get_mail_disabled;
  iface->get_calendar_disabled = goa_account_proxy_get_calendar_disabled;
  iface->get_contacts_disabled = goa_account_proxy_get_contacts_disabled;
  iface->get_chat_disabled = goa_account_proxy_get_chat_disabled;
  iface->get_documents_disabled = goa_account_proxy_get_documents_disabled;
  iface->get_maps_disabled = goa_account_proxy_get_maps_disabled;
  iface->get_music_disabled = goa_account_proxy_get_music_disabled;
  iface->get_printers_disabled = goa_account_proxy_get_printers_disabled;
  iface->get_photos_disabled = goa_account_proxy_get_photos_disabled;
  iface->get_files_disabled = goa_account_proxy_get_files_disabled;
  iface->get_ticketing_disabled = goa_account_proxy_get_ticketing_disabled;
  iface->get_todo_disabled = goa_account_proxy_get_todo_disabled;
  iface->get_read_later_disabled = goa_account_proxy_get_read_later_disabled;
}

/**
 * goa_account_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_account_proxy_new_finish() to get the result of the operation.
 *
 * See goa_account_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_account_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_ACCOUNT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
}

/**
 * goa_account_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_account_proxy_new().
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}

/**
 * goa_account_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_account_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_ACCOUNT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}


/**
 * goa_account_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_account_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_account_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_account_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_account_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_ACCOUNT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
}

/**
 * goa_account_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_account_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_account_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}

/**
 * goa_account_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_account_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_account_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaAccountProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaAccount *
goa_account_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_ACCOUNT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Account", NULL);
  if (ret != NULL)
    return GOA_ACCOUNT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaAccountSkeleton:
 *
 * The #GoaAccountSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaAccountSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaAccountSkeleton.
 */

struct _GoaAccountSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_account_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_ACCOUNT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_ACCOUNT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_account_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_account_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_account_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_account_skeleton_vtable =
{
  _goa_account_skeleton_handle_method_call,
  _goa_account_skeleton_handle_get_property,
  _goa_account_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_account_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_account_interface_info ();
}

static GDBusInterfaceVTable *
goa_account_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_account_skeleton_vtable;
}

static GVariant *
goa_account_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_account_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_account_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_account_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_account_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Account", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_account_emit_changed (gpointer user_data);

static void
goa_account_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_account_emit_changed (skeleton);
}

static void goa_account_skeleton_iface_init (GoaAccountIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaAccountSkeleton, goa_account_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaAccountSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_ACCOUNT, goa_account_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaAccountSkeleton, goa_account_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_ACCOUNT, goa_account_skeleton_iface_init))

#endif
static void
goa_account_skeleton_finalize (GObject *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  guint n;
  for (n = 0; n < 22; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_account_skeleton_parent_class)->finalize (object);
}

static void
goa_account_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 22);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_account_emit_changed (gpointer user_data)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Account",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_account_schedule_emit_changed (GoaAccountSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_account_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_account_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_account_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_account_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 22);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_account_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_account_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_account_skeleton_init (GoaAccountSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_account_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_ACCOUNT_SKELETON, GoaAccountSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 22);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[8], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[9], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[10], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[11], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[12], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[13], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[14], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[15], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[16], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[17], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[18], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[19], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[20], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[21], G_TYPE_BOOLEAN);
}

static const gchar *
goa_account_skeleton_get_provider_type (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_provider_name (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_provider_icon (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_id (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_is_locked (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_is_temporary (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_attention_needed (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_identity (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_account_skeleton_get_presentation_identity (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[8]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_mail_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[9]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_calendar_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[10]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_contacts_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[11]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_chat_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[12]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_documents_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[13]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_maps_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[14]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_music_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[15]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_printers_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[16]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_photos_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[17]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_files_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[18]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_ticketing_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[19]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_todo_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[20]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_account_skeleton_get_read_later_disabled (GoaAccount *object)
{
  GoaAccountSkeleton *skeleton = GOA_ACCOUNT_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[21]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_account_skeleton_class_init (GoaAccountSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_account_skeleton_finalize;
  gobject_class->get_property = goa_account_skeleton_get_property;
  gobject_class->set_property = goa_account_skeleton_set_property;
  gobject_class->notify       = goa_account_skeleton_notify;


  goa_account_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_account_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_account_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_account_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_account_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaAccountSkeletonPrivate));
#endif
}

static void
goa_account_skeleton_iface_init (GoaAccountIface *iface)
{
  iface->get_provider_type = goa_account_skeleton_get_provider_type;
  iface->get_provider_name = goa_account_skeleton_get_provider_name;
  iface->get_provider_icon = goa_account_skeleton_get_provider_icon;
  iface->get_id = goa_account_skeleton_get_id;
  iface->get_is_locked = goa_account_skeleton_get_is_locked;
  iface->get_is_temporary = goa_account_skeleton_get_is_temporary;
  iface->get_attention_needed = goa_account_skeleton_get_attention_needed;
  iface->get_identity = goa_account_skeleton_get_identity;
  iface->get_presentation_identity = goa_account_skeleton_get_presentation_identity;
  iface->get_mail_disabled = goa_account_skeleton_get_mail_disabled;
  iface->get_calendar_disabled = goa_account_skeleton_get_calendar_disabled;
  iface->get_contacts_disabled = goa_account_skeleton_get_contacts_disabled;
  iface->get_chat_disabled = goa_account_skeleton_get_chat_disabled;
  iface->get_documents_disabled = goa_account_skeleton_get_documents_disabled;
  iface->get_maps_disabled = goa_account_skeleton_get_maps_disabled;
  iface->get_music_disabled = goa_account_skeleton_get_music_disabled;
  iface->get_printers_disabled = goa_account_skeleton_get_printers_disabled;
  iface->get_photos_disabled = goa_account_skeleton_get_photos_disabled;
  iface->get_files_disabled = goa_account_skeleton_get_files_disabled;
  iface->get_ticketing_disabled = goa_account_skeleton_get_ticketing_disabled;
  iface->get_todo_disabled = goa_account_skeleton_get_todo_disabled;
  iface->get_read_later_disabled = goa_account_skeleton_get_read_later_disabled;
}

/**
 * goa_account_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>.
 *
 * Returns: (transfer full) (type GoaAccountSkeleton): The skeleton object.
 */
GoaAccount *
goa_account_skeleton_new (void)
{
  return GOA_ACCOUNT (g_object_new (GOA_TYPE_ACCOUNT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.OAuth2Based
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaOAuth2Based
 * @title: GoaOAuth2Based
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.OAuth2Based D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.OAuth2Based ---- */

static const _ExtendedGDBusArgInfo _goa_oauth2_based_method_info_get_access_token_OUT_ARG_access_token =
{
  {
    -1,
    (gchar *) "access_token",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_oauth2_based_method_info_get_access_token_OUT_ARG_expires_in =
{
  {
    -1,
    (gchar *) "expires_in",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_oauth2_based_method_info_get_access_token_OUT_ARG_pointers[] =
{
  &_goa_oauth2_based_method_info_get_access_token_OUT_ARG_access_token.parent_struct,
  &_goa_oauth2_based_method_info_get_access_token_OUT_ARG_expires_in.parent_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_oauth2_based_method_info_get_access_token =
{
  {
    -1,
    (gchar *) "GetAccessToken",
    NULL,
    (GDBusArgInfo **) &_goa_oauth2_based_method_info_get_access_token_OUT_ARG_pointers,
    NULL
  },
  "handle-get-access-token",
  FALSE
};

static const GDBusMethodInfo * const _goa_oauth2_based_method_info_pointers[] =
{
  &_goa_oauth2_based_method_info_get_access_token.parent_struct,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_oauth2_based_property_info_client_id =
{
  {
    -1,
    (gchar *) "ClientId",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "client-id",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_oauth2_based_property_info_client_secret =
{
  {
    -1,
    (gchar *) "ClientSecret",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "client-secret",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_oauth2_based_property_info_pointers[] =
{
  &_goa_oauth2_based_property_info_client_id.parent_struct,
  &_goa_oauth2_based_property_info_client_secret.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_oauth2_based_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.OAuth2Based",
    (GDBusMethodInfo **) &_goa_oauth2_based_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_oauth2_based_property_info_pointers,
    NULL
  },
  "oauth2-based",
};


/**
 * goa_oauth2_based_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_oauth2_based_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct;
}

/**
 * goa_oauth2_based_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaOAuth2Based interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_oauth2_based_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "client-id");
  g_object_class_override_property (klass, property_id_begin++, "client-secret");
  return property_id_begin - 1;
}



/**
 * GoaOAuth2Based:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>.
 */

/**
 * GoaOAuth2BasedIface:
 * @parent_iface: The parent interface.
 * @handle_get_access_token: Handler for the #GoaOAuth2Based::handle-get-access-token signal.
 * @get_client_id: Getter for the #GoaOAuth2Based:client-id property.
 * @get_client_secret: Getter for the #GoaOAuth2Based:client-secret property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>.
 */

typedef GoaOAuth2BasedIface GoaOAuth2BasedInterface;
G_DEFINE_INTERFACE (GoaOAuth2Based, goa_oauth2_based, G_TYPE_OBJECT)

static void
goa_oauth2_based_default_init (GoaOAuth2BasedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaOAuth2Based::handle-get-access-token:
   * @object: A #GoaOAuth2Based.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_oauth2_based_complete_get_access_token() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-access-token",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaOAuth2BasedIface, handle_get_access_token),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaOAuth2Based:client-id:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("client-id", "ClientId", "ClientId", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaOAuth2Based:client-secret:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("client-secret", "ClientSecret", "ClientSecret", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_oauth2_based_get_client_id: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth2_based_dup_client_id() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth2_based_get_client_id (GoaOAuth2Based *object)
{
  return GOA_OAUTH2_BASED_GET_IFACE (object)->get_client_id (object);
}

/**
 * goa_oauth2_based_dup_client_id: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth2_based_dup_client_id (GoaOAuth2Based *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "client-id", &value, NULL);
  return value;
}

/**
 * goa_oauth2_based_set_client_id: (skip)
 * @object: A #GoaOAuth2Based.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientId">"ClientId"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth2_based_set_client_id (GoaOAuth2Based *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "client-id", value, NULL);
}

/**
 * goa_oauth2_based_get_client_secret: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth2_based_dup_client_secret() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth2_based_get_client_secret (GoaOAuth2Based *object)
{
  return GOA_OAUTH2_BASED_GET_IFACE (object)->get_client_secret (object);
}

/**
 * goa_oauth2_based_dup_client_secret: (skip)
 * @object: A #GoaOAuth2Based.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth2_based_dup_client_secret (GoaOAuth2Based *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "client-secret", &value, NULL);
  return value;
}

/**
 * goa_oauth2_based_set_client_secret: (skip)
 * @object: A #GoaOAuth2Based.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuth2Based.ClientSecret">"ClientSecret"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth2_based_set_client_secret (GoaOAuth2Based *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "client-secret", value, NULL);
}

/**
 * goa_oauth2_based_call_get_access_token:
 * @proxy: A #GoaOAuth2BasedProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_oauth2_based_call_get_access_token_finish() to get the result of the operation.
 *
 * See goa_oauth2_based_call_get_access_token_sync() for the synchronous, blocking version of this method.
 */
void
goa_oauth2_based_call_get_access_token (
    GoaOAuth2Based *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_oauth2_based_call_get_access_token_finish:
 * @proxy: A #GoaOAuth2BasedProxy.
 * @out_access_token: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth2_based_call_get_access_token().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_oauth2_based_call_get_access_token().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_oauth2_based_call_get_access_token_finish (
    GoaOAuth2Based *proxy,
    gchar **out_access_token,
    gint *out_expires_in,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(si)",
                 out_access_token,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth2_based_call_get_access_token_sync:
 * @proxy: A #GoaOAuth2BasedProxy.
 * @out_access_token: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_oauth2_based_call_get_access_token() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_oauth2_based_call_get_access_token_sync (
    GoaOAuth2Based *proxy,
    gchar **out_access_token,
    gint *out_expires_in,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(si)",
                 out_access_token,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth2_based_complete_get_access_token:
 * @object: A #GoaOAuth2Based.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @access_token: Parameter to return.
 * @expires_in: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuth2Based.GetAccessToken">GetAccessToken()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_oauth2_based_complete_get_access_token (
    GoaOAuth2Based *object,
    GDBusMethodInvocation *invocation,
    const gchar *access_token,
    gint expires_in)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(si)",
                   access_token,
                   expires_in));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaOAuth2BasedProxy:
 *
 * The #GoaOAuth2BasedProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuth2BasedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuth2BasedProxy.
 */

struct _GoaOAuth2BasedProxyPrivate
{
  GData *qdata;
};

static void goa_oauth2_based_proxy_iface_init (GoaOAuth2BasedIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaOAuth2BasedProxy, goa_oauth2_based_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaOAuth2BasedProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH2_BASED, goa_oauth2_based_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaOAuth2BasedProxy, goa_oauth2_based_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH2_BASED, goa_oauth2_based_proxy_iface_init))

#endif
static void
goa_oauth2_based_proxy_finalize (GObject *object)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_oauth2_based_proxy_parent_class)->finalize (object);
}

static void
goa_oauth2_based_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_oauth2_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_oauth2_based_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.OAuth2Based: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_oauth2_based_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_oauth2_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.OAuth2Based", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_oauth2_based_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_oauth2_based_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_OAUTH2_BASED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH2_BASED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_oauth2_based_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_oauth2_based_proxy_get_client_id (GoaOAuth2Based *object)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ClientId");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_oauth2_based_proxy_get_client_secret (GoaOAuth2Based *object)
{
  GoaOAuth2BasedProxy *proxy = GOA_OAUTH2_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ClientSecret");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_oauth2_based_proxy_init (GoaOAuth2BasedProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_oauth2_based_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_OAUTH2_BASED_PROXY, GoaOAuth2BasedProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_oauth2_based_interface_info ());
}

static void
goa_oauth2_based_proxy_class_init (GoaOAuth2BasedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_oauth2_based_proxy_finalize;
  gobject_class->get_property = goa_oauth2_based_proxy_get_property;
  gobject_class->set_property = goa_oauth2_based_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_oauth2_based_proxy_g_signal;
  proxy_class->g_properties_changed = goa_oauth2_based_proxy_g_properties_changed;

  goa_oauth2_based_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaOAuth2BasedProxyPrivate));
#endif
}

static void
goa_oauth2_based_proxy_iface_init (GoaOAuth2BasedIface *iface)
{
  iface->get_client_id = goa_oauth2_based_proxy_get_client_id;
  iface->get_client_secret = goa_oauth2_based_proxy_get_client_secret;
}

/**
 * goa_oauth2_based_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_oauth2_based_proxy_new_finish() to get the result of the operation.
 *
 * See goa_oauth2_based_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth2_based_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH2_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
}

/**
 * goa_oauth2_based_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth2_based_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth2_based_proxy_new().
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth2_based_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth2_based_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH2_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}


/**
 * goa_oauth2_based_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_oauth2_based_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_oauth2_based_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_oauth2_based_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth2_based_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH2_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
}

/**
 * goa_oauth2_based_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth2_based_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth2_based_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth2_based_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_oauth2_based_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth2_based_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuth2BasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuth2Based *
goa_oauth2_based_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH2_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuth2Based", NULL);
  if (ret != NULL)
    return GOA_OAUTH2_BASED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaOAuth2BasedSkeleton:
 *
 * The #GoaOAuth2BasedSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuth2BasedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuth2BasedSkeleton.
 */

struct _GoaOAuth2BasedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_oauth2_based_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_OAUTH2_BASED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH2_BASED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_oauth2_based_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_oauth2_based_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth2_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_oauth2_based_skeleton_vtable =
{
  _goa_oauth2_based_skeleton_handle_method_call,
  _goa_oauth2_based_skeleton_handle_get_property,
  _goa_oauth2_based_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_oauth2_based_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_oauth2_based_interface_info ();
}

static GDBusInterfaceVTable *
goa_oauth2_based_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_oauth2_based_skeleton_vtable;
}

static GVariant *
goa_oauth2_based_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_oauth2_based_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_oauth2_based_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_oauth2_based_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_oauth2_based_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.OAuth2Based", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_oauth2_based_emit_changed (gpointer user_data);

static void
goa_oauth2_based_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_oauth2_based_emit_changed (skeleton);
}

static void goa_oauth2_based_skeleton_iface_init (GoaOAuth2BasedIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaOAuth2BasedSkeleton, goa_oauth2_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaOAuth2BasedSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH2_BASED, goa_oauth2_based_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaOAuth2BasedSkeleton, goa_oauth2_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH2_BASED, goa_oauth2_based_skeleton_iface_init))

#endif
static void
goa_oauth2_based_skeleton_finalize (GObject *object)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_oauth2_based_skeleton_parent_class)->finalize (object);
}

static void
goa_oauth2_based_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_oauth2_based_emit_changed (gpointer user_data)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.OAuth2Based",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_oauth2_based_schedule_emit_changed (GoaOAuth2BasedSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_oauth2_based_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_oauth2_based_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_oauth2_based_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_oauth2_based_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_oauth2_based_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_oauth2_based_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_oauth2_based_skeleton_init (GoaOAuth2BasedSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_oauth2_based_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_OAUTH2_BASED_SKELETON, GoaOAuth2BasedSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static const gchar *
goa_oauth2_based_skeleton_get_client_id (GoaOAuth2Based *object)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_oauth2_based_skeleton_get_client_secret (GoaOAuth2Based *object)
{
  GoaOAuth2BasedSkeleton *skeleton = GOA_OAUTH2_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_oauth2_based_skeleton_class_init (GoaOAuth2BasedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_oauth2_based_skeleton_finalize;
  gobject_class->get_property = goa_oauth2_based_skeleton_get_property;
  gobject_class->set_property = goa_oauth2_based_skeleton_set_property;
  gobject_class->notify       = goa_oauth2_based_skeleton_notify;


  goa_oauth2_based_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_oauth2_based_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_oauth2_based_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_oauth2_based_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_oauth2_based_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaOAuth2BasedSkeletonPrivate));
#endif
}

static void
goa_oauth2_based_skeleton_iface_init (GoaOAuth2BasedIface *iface)
{
  iface->get_client_id = goa_oauth2_based_skeleton_get_client_id;
  iface->get_client_secret = goa_oauth2_based_skeleton_get_client_secret;
}

/**
 * goa_oauth2_based_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>.
 *
 * Returns: (transfer full) (type GoaOAuth2BasedSkeleton): The skeleton object.
 */
GoaOAuth2Based *
goa_oauth2_based_skeleton_new (void)
{
  return GOA_OAUTH2_BASED (g_object_new (GOA_TYPE_OAUTH2_BASED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.OAuthBased
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaOAuthBased
 * @title: GoaOAuthBased
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.OAuthBased D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.OAuthBased ---- */

static const _ExtendedGDBusArgInfo _goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token =
{
  {
    -1,
    (gchar *) "access_token",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token_secret =
{
  {
    -1,
    (gchar *) "access_token_secret",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_oauth_based_method_info_get_access_token_OUT_ARG_expires_in =
{
  {
    -1,
    (gchar *) "expires_in",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_oauth_based_method_info_get_access_token_OUT_ARG_pointers[] =
{
  &_goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token.parent_struct,
  &_goa_oauth_based_method_info_get_access_token_OUT_ARG_access_token_secret.parent_struct,
  &_goa_oauth_based_method_info_get_access_token_OUT_ARG_expires_in.parent_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_oauth_based_method_info_get_access_token =
{
  {
    -1,
    (gchar *) "GetAccessToken",
    NULL,
    (GDBusArgInfo **) &_goa_oauth_based_method_info_get_access_token_OUT_ARG_pointers,
    NULL
  },
  "handle-get-access-token",
  FALSE
};

static const GDBusMethodInfo * const _goa_oauth_based_method_info_pointers[] =
{
  &_goa_oauth_based_method_info_get_access_token.parent_struct,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_oauth_based_property_info_consumer_key =
{
  {
    -1,
    (gchar *) "ConsumerKey",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "consumer-key",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_oauth_based_property_info_consumer_secret =
{
  {
    -1,
    (gchar *) "ConsumerSecret",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "consumer-secret",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_oauth_based_property_info_pointers[] =
{
  &_goa_oauth_based_property_info_consumer_key.parent_struct,
  &_goa_oauth_based_property_info_consumer_secret.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_oauth_based_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.OAuthBased",
    (GDBusMethodInfo **) &_goa_oauth_based_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_oauth_based_property_info_pointers,
    NULL
  },
  "oauth-based",
};


/**
 * goa_oauth_based_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_oauth_based_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct;
}

/**
 * goa_oauth_based_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaOAuthBased interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_oauth_based_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "consumer-key");
  g_object_class_override_property (klass, property_id_begin++, "consumer-secret");
  return property_id_begin - 1;
}



/**
 * GoaOAuthBased:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>.
 */

/**
 * GoaOAuthBasedIface:
 * @parent_iface: The parent interface.
 * @handle_get_access_token: Handler for the #GoaOAuthBased::handle-get-access-token signal.
 * @get_consumer_key: Getter for the #GoaOAuthBased:consumer-key property.
 * @get_consumer_secret: Getter for the #GoaOAuthBased:consumer-secret property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>.
 */

typedef GoaOAuthBasedIface GoaOAuthBasedInterface;
G_DEFINE_INTERFACE (GoaOAuthBased, goa_oauth_based, G_TYPE_OBJECT)

static void
goa_oauth_based_default_init (GoaOAuthBasedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaOAuthBased::handle-get-access-token:
   * @object: A #GoaOAuthBased.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_oauth_based_complete_get_access_token() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-access-token",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaOAuthBasedIface, handle_get_access_token),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaOAuthBased:consumer-key:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("consumer-key", "ConsumerKey", "ConsumerKey", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaOAuthBased:consumer-secret:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("consumer-secret", "ConsumerSecret", "ConsumerSecret", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_oauth_based_get_consumer_key: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth_based_dup_consumer_key() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth_based_get_consumer_key (GoaOAuthBased *object)
{
  return GOA_OAUTH_BASED_GET_IFACE (object)->get_consumer_key (object);
}

/**
 * goa_oauth_based_dup_consumer_key: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth_based_dup_consumer_key (GoaOAuthBased *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "consumer-key", &value, NULL);
  return value;
}

/**
 * goa_oauth_based_set_consumer_key: (skip)
 * @object: A #GoaOAuthBased.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerKey">"ConsumerKey"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth_based_set_consumer_key (GoaOAuthBased *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "consumer-key", value, NULL);
}

/**
 * goa_oauth_based_get_consumer_secret: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_oauth_based_dup_consumer_secret() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_oauth_based_get_consumer_secret (GoaOAuthBased *object)
{
  return GOA_OAUTH_BASED_GET_IFACE (object)->get_consumer_secret (object);
}

/**
 * goa_oauth_based_dup_consumer_secret: (skip)
 * @object: A #GoaOAuthBased.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_oauth_based_dup_consumer_secret (GoaOAuthBased *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "consumer-secret", &value, NULL);
  return value;
}

/**
 * goa_oauth_based_set_consumer_secret: (skip)
 * @object: A #GoaOAuthBased.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-OAuthBased.ConsumerSecret">"ConsumerSecret"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_oauth_based_set_consumer_secret (GoaOAuthBased *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "consumer-secret", value, NULL);
}

/**
 * goa_oauth_based_call_get_access_token:
 * @proxy: A #GoaOAuthBasedProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_oauth_based_call_get_access_token_finish() to get the result of the operation.
 *
 * See goa_oauth_based_call_get_access_token_sync() for the synchronous, blocking version of this method.
 */
void
goa_oauth_based_call_get_access_token (
    GoaOAuthBased *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_oauth_based_call_get_access_token_finish:
 * @proxy: A #GoaOAuthBasedProxy.
 * @out_access_token: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @out_access_token_secret: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth_based_call_get_access_token().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_oauth_based_call_get_access_token().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_oauth_based_call_get_access_token_finish (
    GoaOAuthBased *proxy,
    gchar **out_access_token,
    gchar **out_access_token_secret,
    gint *out_expires_in,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ssi)",
                 out_access_token,
                 out_access_token_secret,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth_based_call_get_access_token_sync:
 * @proxy: A #GoaOAuthBasedProxy.
 * @out_access_token: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @out_access_token_secret: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @out_expires_in: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_oauth_based_call_get_access_token() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_oauth_based_call_get_access_token_sync (
    GoaOAuthBased *proxy,
    gchar **out_access_token,
    gchar **out_access_token_secret,
    gint *out_expires_in,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetAccessToken",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ssi)",
                 out_access_token,
                 out_access_token_secret,
                 out_expires_in);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_oauth_based_complete_get_access_token:
 * @object: A #GoaOAuthBased.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @access_token: Parameter to return.
 * @access_token_secret: Parameter to return.
 * @expires_in: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-OAuthBased.GetAccessToken">GetAccessToken()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_oauth_based_complete_get_access_token (
    GoaOAuthBased *object,
    GDBusMethodInvocation *invocation,
    const gchar *access_token,
    const gchar *access_token_secret,
    gint expires_in)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(ssi)",
                   access_token,
                   access_token_secret,
                   expires_in));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaOAuthBasedProxy:
 *
 * The #GoaOAuthBasedProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuthBasedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuthBasedProxy.
 */

struct _GoaOAuthBasedProxyPrivate
{
  GData *qdata;
};

static void goa_oauth_based_proxy_iface_init (GoaOAuthBasedIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaOAuthBasedProxy, goa_oauth_based_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaOAuthBasedProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH_BASED, goa_oauth_based_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaOAuthBasedProxy, goa_oauth_based_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH_BASED, goa_oauth_based_proxy_iface_init))

#endif
static void
goa_oauth_based_proxy_finalize (GObject *object)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_oauth_based_proxy_parent_class)->finalize (object);
}

static void
goa_oauth_based_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_oauth_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_oauth_based_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.OAuthBased: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_oauth_based_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_oauth_based_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.OAuthBased", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_oauth_based_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_oauth_based_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_OAUTH_BASED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH_BASED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_oauth_based_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_oauth_based_proxy_get_consumer_key (GoaOAuthBased *object)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConsumerKey");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_oauth_based_proxy_get_consumer_secret (GoaOAuthBased *object)
{
  GoaOAuthBasedProxy *proxy = GOA_OAUTH_BASED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConsumerSecret");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_oauth_based_proxy_init (GoaOAuthBasedProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_oauth_based_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_OAUTH_BASED_PROXY, GoaOAuthBasedProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_oauth_based_interface_info ());
}

static void
goa_oauth_based_proxy_class_init (GoaOAuthBasedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_oauth_based_proxy_finalize;
  gobject_class->get_property = goa_oauth_based_proxy_get_property;
  gobject_class->set_property = goa_oauth_based_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_oauth_based_proxy_g_signal;
  proxy_class->g_properties_changed = goa_oauth_based_proxy_g_properties_changed;

  goa_oauth_based_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaOAuthBasedProxyPrivate));
#endif
}

static void
goa_oauth_based_proxy_iface_init (GoaOAuthBasedIface *iface)
{
  iface->get_consumer_key = goa_oauth_based_proxy_get_consumer_key;
  iface->get_consumer_secret = goa_oauth_based_proxy_get_consumer_secret;
}

/**
 * goa_oauth_based_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_oauth_based_proxy_new_finish() to get the result of the operation.
 *
 * See goa_oauth_based_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth_based_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
}

/**
 * goa_oauth_based_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth_based_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth_based_proxy_new().
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth_based_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth_based_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}


/**
 * goa_oauth_based_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_oauth_based_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_oauth_based_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_oauth_based_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_oauth_based_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_OAUTH_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
}

/**
 * goa_oauth_based_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_oauth_based_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_oauth_based_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}

/**
 * goa_oauth_based_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_oauth_based_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_oauth_based_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaOAuthBasedProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaOAuthBased *
goa_oauth_based_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OAUTH_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.OAuthBased", NULL);
  if (ret != NULL)
    return GOA_OAUTH_BASED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaOAuthBasedSkeleton:
 *
 * The #GoaOAuthBasedSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaOAuthBasedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaOAuthBasedSkeleton.
 */

struct _GoaOAuthBasedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_oauth_based_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_OAUTH_BASED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_OAUTH_BASED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_oauth_based_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_oauth_based_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_oauth_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_oauth_based_skeleton_vtable =
{
  _goa_oauth_based_skeleton_handle_method_call,
  _goa_oauth_based_skeleton_handle_get_property,
  _goa_oauth_based_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_oauth_based_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_oauth_based_interface_info ();
}

static GDBusInterfaceVTable *
goa_oauth_based_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_oauth_based_skeleton_vtable;
}

static GVariant *
goa_oauth_based_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_oauth_based_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_oauth_based_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_oauth_based_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_oauth_based_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.OAuthBased", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_oauth_based_emit_changed (gpointer user_data);

static void
goa_oauth_based_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_oauth_based_emit_changed (skeleton);
}

static void goa_oauth_based_skeleton_iface_init (GoaOAuthBasedIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaOAuthBasedSkeleton, goa_oauth_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaOAuthBasedSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH_BASED, goa_oauth_based_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaOAuthBasedSkeleton, goa_oauth_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OAUTH_BASED, goa_oauth_based_skeleton_iface_init))

#endif
static void
goa_oauth_based_skeleton_finalize (GObject *object)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_oauth_based_skeleton_parent_class)->finalize (object);
}

static void
goa_oauth_based_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_oauth_based_emit_changed (gpointer user_data)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.OAuthBased",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_oauth_based_schedule_emit_changed (GoaOAuthBasedSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_oauth_based_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_oauth_based_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_oauth_based_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_oauth_based_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_oauth_based_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_oauth_based_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_oauth_based_skeleton_init (GoaOAuthBasedSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_oauth_based_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_OAUTH_BASED_SKELETON, GoaOAuthBasedSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static const gchar *
goa_oauth_based_skeleton_get_consumer_key (GoaOAuthBased *object)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_oauth_based_skeleton_get_consumer_secret (GoaOAuthBased *object)
{
  GoaOAuthBasedSkeleton *skeleton = GOA_OAUTH_BASED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_oauth_based_skeleton_class_init (GoaOAuthBasedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_oauth_based_skeleton_finalize;
  gobject_class->get_property = goa_oauth_based_skeleton_get_property;
  gobject_class->set_property = goa_oauth_based_skeleton_set_property;
  gobject_class->notify       = goa_oauth_based_skeleton_notify;


  goa_oauth_based_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_oauth_based_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_oauth_based_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_oauth_based_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_oauth_based_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaOAuthBasedSkeletonPrivate));
#endif
}

static void
goa_oauth_based_skeleton_iface_init (GoaOAuthBasedIface *iface)
{
  iface->get_consumer_key = goa_oauth_based_skeleton_get_consumer_key;
  iface->get_consumer_secret = goa_oauth_based_skeleton_get_consumer_secret;
}

/**
 * goa_oauth_based_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>.
 *
 * Returns: (transfer full) (type GoaOAuthBasedSkeleton): The skeleton object.
 */
GoaOAuthBased *
goa_oauth_based_skeleton_new (void)
{
  return GOA_OAUTH_BASED (g_object_new (GOA_TYPE_OAUTH_BASED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.PasswordBased
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaPasswordBased
 * @title: GoaPasswordBased
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.PasswordBased D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.PasswordBased ---- */

static const _ExtendedGDBusArgInfo _goa_password_based_method_info_get_password_IN_ARG_id =
{
  {
    -1,
    (gchar *) "id",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_password_based_method_info_get_password_IN_ARG_pointers[] =
{
  &_goa_password_based_method_info_get_password_IN_ARG_id.parent_struct,
  NULL
};

static const _ExtendedGDBusArgInfo _goa_password_based_method_info_get_password_OUT_ARG_password =
{
  {
    -1,
    (gchar *) "password",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_password_based_method_info_get_password_OUT_ARG_pointers[] =
{
  &_goa_password_based_method_info_get_password_OUT_ARG_password.parent_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_password_based_method_info_get_password =
{
  {
    -1,
    (gchar *) "GetPassword",
    (GDBusArgInfo **) &_goa_password_based_method_info_get_password_IN_ARG_pointers,
    (GDBusArgInfo **) &_goa_password_based_method_info_get_password_OUT_ARG_pointers,
    NULL
  },
  "handle-get-password",
  FALSE
};

static const GDBusMethodInfo * const _goa_password_based_method_info_pointers[] =
{
  &_goa_password_based_method_info_get_password.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_password_based_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.PasswordBased",
    (GDBusMethodInfo **) &_goa_password_based_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "password-based",
};


/**
 * goa_password_based_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.6.0
 */
GDBusInterfaceInfo *
goa_password_based_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct;
}

/**
 * goa_password_based_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaPasswordBased interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.6.0
 */
guint
goa_password_based_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaPasswordBased:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>.
 *
 * Since: 3.6.0
 */

/**
 * GoaPasswordBasedIface:
 * @parent_iface: The parent interface.
 * @handle_get_password: Handler for the #GoaPasswordBased::handle-get-password signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>.
 *
 * Since: 3.6.0
 */

typedef GoaPasswordBasedIface GoaPasswordBasedInterface;
G_DEFINE_INTERFACE (GoaPasswordBased, goa_password_based, G_TYPE_OBJECT)

static void
goa_password_based_default_init (GoaPasswordBasedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaPasswordBased::handle-get-password:
   * @object: A #GoaPasswordBased.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_id: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_password_based_complete_get_password() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 3.6.0
   */
  g_signal_new ("handle-get-password",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaPasswordBasedIface, handle_get_password),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

}

/**
 * goa_password_based_call_get_password:
 * @proxy: A #GoaPasswordBasedProxy.
 * @arg_id: Argument to pass with the method invocation.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_password_based_call_get_password_finish() to get the result of the operation.
 *
 * See goa_password_based_call_get_password_sync() for the synchronous, blocking version of this method.
 *
 * Since: 3.6.0
 */
void
goa_password_based_call_get_password (
    GoaPasswordBased *proxy,
    const gchar *arg_id,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetPassword",
    g_variant_new ("(s)",
                   arg_id),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_password_based_call_get_password_finish:
 * @proxy: A #GoaPasswordBasedProxy.
 * @out_password: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_password_based_call_get_password().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_password_based_call_get_password().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 *
 * Since: 3.6.0
 */
gboolean
goa_password_based_call_get_password_finish (
    GoaPasswordBased *proxy,
    gchar **out_password,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_password);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_password_based_call_get_password_sync:
 * @proxy: A #GoaPasswordBasedProxy.
 * @arg_id: Argument to pass with the method invocation.
 * @out_password: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_password_based_call_get_password() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 *
 * Since: 3.6.0
 */
gboolean
goa_password_based_call_get_password_sync (
    GoaPasswordBased *proxy,
    const gchar *arg_id,
    gchar **out_password,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetPassword",
    g_variant_new ("(s)",
                   arg_id),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_password);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_password_based_complete_get_password:
 * @object: A #GoaPasswordBased.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @password: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-PasswordBased.GetPassword">GetPassword()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 3.6.0
 */
void
goa_password_based_complete_get_password (
    GoaPasswordBased *object,
    GDBusMethodInvocation *invocation,
    const gchar *password)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   password));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaPasswordBasedProxy:
 *
 * The #GoaPasswordBasedProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaPasswordBasedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPasswordBasedProxy.
 *
 * Since: 3.6.0
 */

struct _GoaPasswordBasedProxyPrivate
{
  GData *qdata;
};

static void goa_password_based_proxy_iface_init (GoaPasswordBasedIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaPasswordBasedProxy, goa_password_based_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaPasswordBasedProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PASSWORD_BASED, goa_password_based_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaPasswordBasedProxy, goa_password_based_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PASSWORD_BASED, goa_password_based_proxy_iface_init))

#endif
static void
goa_password_based_proxy_finalize (GObject *object)
{
  GoaPasswordBasedProxy *proxy = GOA_PASSWORD_BASED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_password_based_proxy_parent_class)->finalize (object);
}

static void
goa_password_based_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_password_based_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_password_based_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_PASSWORD_BASED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PASSWORD_BASED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_password_based_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaPasswordBasedProxy *proxy = GOA_PASSWORD_BASED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_password_based_proxy_init (GoaPasswordBasedProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_password_based_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_PASSWORD_BASED_PROXY, GoaPasswordBasedProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_password_based_interface_info ());
}

static void
goa_password_based_proxy_class_init (GoaPasswordBasedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_password_based_proxy_finalize;
  gobject_class->get_property = goa_password_based_proxy_get_property;
  gobject_class->set_property = goa_password_based_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_password_based_proxy_g_signal;
  proxy_class->g_properties_changed = goa_password_based_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaPasswordBasedProxyPrivate));
#endif
}

static void
goa_password_based_proxy_iface_init (GoaPasswordBasedIface *iface)
{
}

/**
 * goa_password_based_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_password_based_proxy_new_finish() to get the result of the operation.
 *
 * See goa_password_based_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_password_based_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PASSWORD_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
}

/**
 * goa_password_based_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_password_based_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_password_based_proxy_new().
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}

/**
 * goa_password_based_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_password_based_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PASSWORD_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}


/**
 * goa_password_based_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_password_based_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_password_based_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_password_based_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_password_based_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PASSWORD_BASED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
}

/**
 * goa_password_based_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_password_based_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_password_based_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}

/**
 * goa_password_based_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_password_based_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_password_based_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPasswordBasedProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PASSWORD_BASED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.PasswordBased", NULL);
  if (ret != NULL)
    return GOA_PASSWORD_BASED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaPasswordBasedSkeleton:
 *
 * The #GoaPasswordBasedSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaPasswordBasedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPasswordBasedSkeleton.
 *
 * Since: 3.6.0
 */

struct _GoaPasswordBasedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_password_based_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_PASSWORD_BASED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PASSWORD_BASED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_password_based_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_password_based_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_password_based_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_password_based_skeleton_vtable =
{
  _goa_password_based_skeleton_handle_method_call,
  _goa_password_based_skeleton_handle_get_property,
  _goa_password_based_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_password_based_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_password_based_interface_info ();
}

static GDBusInterfaceVTable *
goa_password_based_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_password_based_skeleton_vtable;
}

static GVariant *
goa_password_based_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_password_based_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_password_based_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_password_based_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_password_based_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.PasswordBased", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_password_based_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_password_based_skeleton_iface_init (GoaPasswordBasedIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaPasswordBasedSkeleton, goa_password_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaPasswordBasedSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PASSWORD_BASED, goa_password_based_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaPasswordBasedSkeleton, goa_password_based_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PASSWORD_BASED, goa_password_based_skeleton_iface_init))

#endif
static void
goa_password_based_skeleton_finalize (GObject *object)
{
  GoaPasswordBasedSkeleton *skeleton = GOA_PASSWORD_BASED_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_password_based_skeleton_parent_class)->finalize (object);
}

static void
goa_password_based_skeleton_init (GoaPasswordBasedSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_password_based_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_PASSWORD_BASED_SKELETON, GoaPasswordBasedSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_password_based_skeleton_class_init (GoaPasswordBasedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_password_based_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_password_based_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_password_based_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_password_based_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_password_based_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaPasswordBasedSkeletonPrivate));
#endif
}

static void
goa_password_based_skeleton_iface_init (GoaPasswordBasedIface *iface)
{
}

/**
 * goa_password_based_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>.
 *
 * Returns: (transfer full) (type GoaPasswordBasedSkeleton): The skeleton object.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *
goa_password_based_skeleton_new (void)
{
  return GOA_PASSWORD_BASED (g_object_new (GOA_TYPE_PASSWORD_BASED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Manager
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaManager
 * @title: GoaManager
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Manager D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Manager ---- */

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_provider =
{
  {
    -1,
    (gchar *) "provider",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_identity =
{
  {
    -1,
    (gchar *) "identity",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_presentation_identity =
{
  {
    -1,
    (gchar *) "presentation_identity",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_credentials =
{
  {
    -1,
    (gchar *) "credentials",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_IN_ARG_details =
{
  {
    -1,
    (gchar *) "details",
    (gchar *) "a{ss}",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_manager_method_info_add_account_IN_ARG_pointers[] =
{
  &_goa_manager_method_info_add_account_IN_ARG_provider.parent_struct,
  &_goa_manager_method_info_add_account_IN_ARG_identity.parent_struct,
  &_goa_manager_method_info_add_account_IN_ARG_presentation_identity.parent_struct,
  &_goa_manager_method_info_add_account_IN_ARG_credentials.parent_struct,
  &_goa_manager_method_info_add_account_IN_ARG_details.parent_struct,
  NULL
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_add_account_OUT_ARG_account_object_path =
{
  {
    -1,
    (gchar *) "account_object_path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_manager_method_info_add_account_OUT_ARG_pointers[] =
{
  &_goa_manager_method_info_add_account_OUT_ARG_account_object_path.parent_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_manager_method_info_add_account =
{
  {
    -1,
    (gchar *) "AddAccount",
    (GDBusArgInfo **) &_goa_manager_method_info_add_account_IN_ARG_pointers,
    (GDBusArgInfo **) &_goa_manager_method_info_add_account_OUT_ARG_pointers,
    NULL
  },
  "handle-add-account",
  FALSE
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_is_supported_provider_IN_ARG_provider_type =
{
  {
    -1,
    (gchar *) "provider_type",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_manager_method_info_is_supported_provider_IN_ARG_pointers[] =
{
  &_goa_manager_method_info_is_supported_provider_IN_ARG_provider_type.parent_struct,
  NULL
};

static const _ExtendedGDBusArgInfo _goa_manager_method_info_is_supported_provider_OUT_ARG_is_supported =
{
  {
    -1,
    (gchar *) "is_supported",
    (gchar *) "b",
    NULL
  },
  FALSE
};

static const GDBusArgInfo * const _goa_manager_method_info_is_supported_provider_OUT_ARG_pointers[] =
{
  &_goa_manager_method_info_is_supported_provider_OUT_ARG_is_supported.parent_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _goa_manager_method_info_is_supported_provider =
{
  {
    -1,
    (gchar *) "IsSupportedProvider",
    (GDBusArgInfo **) &_goa_manager_method_info_is_supported_provider_IN_ARG_pointers,
    (GDBusArgInfo **) &_goa_manager_method_info_is_supported_provider_OUT_ARG_pointers,
    NULL
  },
  "handle-is-supported-provider",
  FALSE
};

static const GDBusMethodInfo * const _goa_manager_method_info_pointers[] =
{
  &_goa_manager_method_info_add_account.parent_struct,
  &_goa_manager_method_info_is_supported_provider.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_manager_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Manager",
    (GDBusMethodInfo **) &_goa_manager_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "manager",
};


/**
 * goa_manager_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_manager_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct;
}

/**
 * goa_manager_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaManager interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_manager_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaManager:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>.
 */

/**
 * GoaManagerIface:
 * @parent_iface: The parent interface.
 * @handle_add_account: Handler for the #GoaManager::handle-add-account signal.
 * @handle_is_supported_provider: Handler for the #GoaManager::handle-is-supported-provider signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>.
 */

typedef GoaManagerIface GoaManagerInterface;
G_DEFINE_INTERFACE (GoaManager, goa_manager, G_TYPE_OBJECT)

static void
goa_manager_default_init (GoaManagerIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaManager::handle-add-account:
   * @object: A #GoaManager.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_provider: Argument passed by remote caller.
   * @arg_identity: Argument passed by remote caller.
   * @arg_presentation_identity: Argument passed by remote caller.
   * @arg_credentials: Argument passed by remote caller.
   * @arg_details: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_manager_complete_add_account() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-add-account",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaManagerIface, handle_add_account),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    6,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /**
   * GoaManager::handle-is-supported-provider:
   * @object: A #GoaManager.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_provider_type: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.IsSupportedProvider">IsSupportedProvider()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_manager_complete_is_supported_provider() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-is-supported-provider",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaManagerIface, handle_is_supported_provider),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

}

/**
 * goa_manager_call_add_account:
 * @proxy: A #GoaManagerProxy.
 * @arg_provider: Argument to pass with the method invocation.
 * @arg_identity: Argument to pass with the method invocation.
 * @arg_presentation_identity: Argument to pass with the method invocation.
 * @arg_credentials: Argument to pass with the method invocation.
 * @arg_details: Argument to pass with the method invocation.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_manager_call_add_account_finish() to get the result of the operation.
 *
 * See goa_manager_call_add_account_sync() for the synchronous, blocking version of this method.
 */
void
goa_manager_call_add_account (
    GoaManager *proxy,
    const gchar *arg_provider,
    const gchar *arg_identity,
    const gchar *arg_presentation_identity,
    GVariant *arg_credentials,
    GVariant *arg_details,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddAccount",
    g_variant_new ("(sss@a{sv}@a{ss})",
                   arg_provider,
                   arg_identity,
                   arg_presentation_identity,
                   arg_credentials,
                   arg_details),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_manager_call_add_account_finish:
 * @proxy: A #GoaManagerProxy.
 * @out_account_object_path: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_call_add_account().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_manager_call_add_account().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_manager_call_add_account_finish (
    GoaManager *proxy,
    gchar **out_account_object_path,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_account_object_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_manager_call_add_account_sync:
 * @proxy: A #GoaManagerProxy.
 * @arg_provider: Argument to pass with the method invocation.
 * @arg_identity: Argument to pass with the method invocation.
 * @arg_presentation_identity: Argument to pass with the method invocation.
 * @arg_credentials: Argument to pass with the method invocation.
 * @arg_details: Argument to pass with the method invocation.
 * @out_account_object_path: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_manager_call_add_account() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_manager_call_add_account_sync (
    GoaManager *proxy,
    const gchar *arg_provider,
    const gchar *arg_identity,
    const gchar *arg_presentation_identity,
    GVariant *arg_credentials,
    GVariant *arg_details,
    gchar **out_account_object_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddAccount",
    g_variant_new ("(sss@a{sv}@a{ss})",
                   arg_provider,
                   arg_identity,
                   arg_presentation_identity,
                   arg_credentials,
                   arg_details),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_account_object_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_manager_call_is_supported_provider:
 * @proxy: A #GoaManagerProxy.
 * @arg_provider_type: Argument to pass with the method invocation.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.IsSupportedProvider">IsSupportedProvider()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_manager_call_is_supported_provider_finish() to get the result of the operation.
 *
 * See goa_manager_call_is_supported_provider_sync() for the synchronous, blocking version of this method.
 */
void
goa_manager_call_is_supported_provider (
    GoaManager *proxy,
    const gchar *arg_provider_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "IsSupportedProvider",
    g_variant_new ("(s)",
                   arg_provider_type),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_manager_call_is_supported_provider_finish:
 * @proxy: A #GoaManagerProxy.
 * @out_is_supported: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_call_is_supported_provider().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_manager_call_is_supported_provider().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_manager_call_is_supported_provider_finish (
    GoaManager *proxy,
    gboolean *out_is_supported,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_is_supported);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_manager_call_is_supported_provider_sync:
 * @proxy: A #GoaManagerProxy.
 * @arg_provider_type: Argument to pass with the method invocation.
 * @out_is_supported: (out) (optional): Return location for return parameter or %NULL to ignore.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.IsSupportedProvider">IsSupportedProvider()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_manager_call_is_supported_provider() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
goa_manager_call_is_supported_provider_sync (
    GoaManager *proxy,
    const gchar *arg_provider_type,
    gboolean *out_is_supported,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "IsSupportedProvider",
    g_variant_new ("(s)",
                   arg_provider_type),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_is_supported);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_manager_complete_add_account:
 * @object: A #GoaManager.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @account_object_path: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.AddAccount">AddAccount()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_manager_complete_add_account (
    GoaManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *account_object_path)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   account_object_path));
}

/**
 * goa_manager_complete_is_supported_provider:
 * @object: A #GoaManager.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @is_supported: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Manager.IsSupportedProvider">IsSupportedProvider()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
goa_manager_complete_is_supported_provider (
    GoaManager *object,
    GDBusMethodInvocation *invocation,
    gboolean is_supported)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   is_supported));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaManagerProxy:
 *
 * The #GoaManagerProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaManagerProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaManagerProxy.
 */

struct _GoaManagerProxyPrivate
{
  GData *qdata;
};

static void goa_manager_proxy_iface_init (GoaManagerIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaManagerProxy, goa_manager_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaManagerProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MANAGER, goa_manager_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaManagerProxy, goa_manager_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MANAGER, goa_manager_proxy_iface_init))

#endif
static void
goa_manager_proxy_finalize (GObject *object)
{
  GoaManagerProxy *proxy = GOA_MANAGER_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_manager_proxy_parent_class)->finalize (object);
}

static void
goa_manager_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_manager_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_manager_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MANAGER);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MANAGER);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_manager_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaManagerProxy *proxy = GOA_MANAGER_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_manager_proxy_init (GoaManagerProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_manager_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MANAGER_PROXY, GoaManagerProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_manager_interface_info ());
}

static void
goa_manager_proxy_class_init (GoaManagerProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_manager_proxy_finalize;
  gobject_class->get_property = goa_manager_proxy_get_property;
  gobject_class->set_property = goa_manager_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_manager_proxy_g_signal;
  proxy_class->g_properties_changed = goa_manager_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaManagerProxyPrivate));
#endif
}

static void
goa_manager_proxy_iface_init (GoaManagerIface *iface)
{
}

/**
 * goa_manager_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_manager_proxy_new_finish() to get the result of the operation.
 *
 * See goa_manager_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_manager_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MANAGER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
}

/**
 * goa_manager_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_manager_proxy_new().
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_manager_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_manager_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MANAGER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}


/**
 * goa_manager_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_manager_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_manager_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_manager_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_manager_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MANAGER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
}

/**
 * goa_manager_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_manager_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_manager_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_manager_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_manager_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_manager_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaManagerProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaManager *
goa_manager_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MANAGER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Manager", NULL);
  if (ret != NULL)
    return GOA_MANAGER (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaManagerSkeleton:
 *
 * The #GoaManagerSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaManagerSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaManagerSkeleton.
 */

struct _GoaManagerSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_manager_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MANAGER);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MANAGER);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_manager_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_manager_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_manager_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_manager_skeleton_vtable =
{
  _goa_manager_skeleton_handle_method_call,
  _goa_manager_skeleton_handle_get_property,
  _goa_manager_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_manager_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_manager_interface_info ();
}

static GDBusInterfaceVTable *
goa_manager_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_manager_skeleton_vtable;
}

static GVariant *
goa_manager_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_manager_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_manager_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_manager_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_manager_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Manager", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_manager_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_manager_skeleton_iface_init (GoaManagerIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaManagerSkeleton, goa_manager_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaManagerSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MANAGER, goa_manager_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaManagerSkeleton, goa_manager_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MANAGER, goa_manager_skeleton_iface_init))

#endif
static void
goa_manager_skeleton_finalize (GObject *object)
{
  GoaManagerSkeleton *skeleton = GOA_MANAGER_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_manager_skeleton_parent_class)->finalize (object);
}

static void
goa_manager_skeleton_init (GoaManagerSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_manager_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MANAGER_SKELETON, GoaManagerSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_manager_skeleton_class_init (GoaManagerSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_manager_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_manager_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_manager_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_manager_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_manager_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaManagerSkeletonPrivate));
#endif
}

static void
goa_manager_skeleton_iface_init (GoaManagerIface *iface)
{
}

/**
 * goa_manager_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>.
 *
 * Returns: (transfer full) (type GoaManagerSkeleton): The skeleton object.
 */
GoaManager *
goa_manager_skeleton_new (void)
{
  return GOA_MANAGER (g_object_new (GOA_TYPE_MANAGER_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Mail
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaMail
 * @title: GoaMail
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Mail D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Mail ---- */

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_email_address =
{
  {
    -1,
    (gchar *) "EmailAddress",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "email-address",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_name =
{
  {
    -1,
    (gchar *) "Name",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "name",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_supported =
{
  {
    -1,
    (gchar *) "ImapSupported",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-supported",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_accept_ssl_errors =
{
  {
    -1,
    (gchar *) "ImapAcceptSslErrors",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-accept-ssl-errors",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_host =
{
  {
    -1,
    (gchar *) "ImapHost",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-host",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_use_ssl =
{
  {
    -1,
    (gchar *) "ImapUseSsl",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-use-ssl",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_use_tls =
{
  {
    -1,
    (gchar *) "ImapUseTls",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-use-tls",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_imap_user_name =
{
  {
    -1,
    (gchar *) "ImapUserName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "imap-user-name",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_supported =
{
  {
    -1,
    (gchar *) "SmtpSupported",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-supported",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_accept_ssl_errors =
{
  {
    -1,
    (gchar *) "SmtpAcceptSslErrors",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-accept-ssl-errors",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_host =
{
  {
    -1,
    (gchar *) "SmtpHost",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-host",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_use_auth =
{
  {
    -1,
    (gchar *) "SmtpUseAuth",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-use-auth",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_auth_login =
{
  {
    -1,
    (gchar *) "SmtpAuthLogin",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-auth-login",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_auth_plain =
{
  {
    -1,
    (gchar *) "SmtpAuthPlain",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-auth-plain",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_auth_xoauth2 =
{
  {
    -1,
    (gchar *) "SmtpAuthXoauth2",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-auth-xoauth2",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_use_ssl =
{
  {
    -1,
    (gchar *) "SmtpUseSsl",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-use-ssl",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_use_tls =
{
  {
    -1,
    (gchar *) "SmtpUseTls",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-use-tls",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_mail_property_info_smtp_user_name =
{
  {
    -1,
    (gchar *) "SmtpUserName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "smtp-user-name",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_mail_property_info_pointers[] =
{
  &_goa_mail_property_info_email_address.parent_struct,
  &_goa_mail_property_info_name.parent_struct,
  &_goa_mail_property_info_imap_supported.parent_struct,
  &_goa_mail_property_info_imap_accept_ssl_errors.parent_struct,
  &_goa_mail_property_info_imap_host.parent_struct,
  &_goa_mail_property_info_imap_use_ssl.parent_struct,
  &_goa_mail_property_info_imap_use_tls.parent_struct,
  &_goa_mail_property_info_imap_user_name.parent_struct,
  &_goa_mail_property_info_smtp_supported.parent_struct,
  &_goa_mail_property_info_smtp_accept_ssl_errors.parent_struct,
  &_goa_mail_property_info_smtp_host.parent_struct,
  &_goa_mail_property_info_smtp_use_auth.parent_struct,
  &_goa_mail_property_info_smtp_auth_login.parent_struct,
  &_goa_mail_property_info_smtp_auth_plain.parent_struct,
  &_goa_mail_property_info_smtp_auth_xoauth2.parent_struct,
  &_goa_mail_property_info_smtp_use_ssl.parent_struct,
  &_goa_mail_property_info_smtp_use_tls.parent_struct,
  &_goa_mail_property_info_smtp_user_name.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_mail_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Mail",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_mail_property_info_pointers,
    NULL
  },
  "mail",
};


/**
 * goa_mail_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_mail_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct;
}

/**
 * goa_mail_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaMail interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_mail_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "email-address");
  g_object_class_override_property (klass, property_id_begin++, "name");
  g_object_class_override_property (klass, property_id_begin++, "imap-supported");
  g_object_class_override_property (klass, property_id_begin++, "imap-accept-ssl-errors");
  g_object_class_override_property (klass, property_id_begin++, "imap-host");
  g_object_class_override_property (klass, property_id_begin++, "imap-use-ssl");
  g_object_class_override_property (klass, property_id_begin++, "imap-use-tls");
  g_object_class_override_property (klass, property_id_begin++, "imap-user-name");
  g_object_class_override_property (klass, property_id_begin++, "smtp-supported");
  g_object_class_override_property (klass, property_id_begin++, "smtp-accept-ssl-errors");
  g_object_class_override_property (klass, property_id_begin++, "smtp-host");
  g_object_class_override_property (klass, property_id_begin++, "smtp-use-auth");
  g_object_class_override_property (klass, property_id_begin++, "smtp-auth-login");
  g_object_class_override_property (klass, property_id_begin++, "smtp-auth-plain");
  g_object_class_override_property (klass, property_id_begin++, "smtp-auth-xoauth2");
  g_object_class_override_property (klass, property_id_begin++, "smtp-use-ssl");
  g_object_class_override_property (klass, property_id_begin++, "smtp-use-tls");
  g_object_class_override_property (klass, property_id_begin++, "smtp-user-name");
  return property_id_begin - 1;
}



/**
 * GoaMail:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>.
 */

/**
 * GoaMailIface:
 * @parent_iface: The parent interface.
 * @get_email_address: Getter for the #GoaMail:email-address property.
 * @get_imap_host: Getter for the #GoaMail:imap-host property.
 * @get_imap_supported: Getter for the #GoaMail:imap-supported property.
 * @get_imap_use_tls: Getter for the #GoaMail:imap-use-tls property.
 * @get_imap_user_name: Getter for the #GoaMail:imap-user-name property.
 * @get_smtp_host: Getter for the #GoaMail:smtp-host property.
 * @get_smtp_supported: Getter for the #GoaMail:smtp-supported property.
 * @get_smtp_use_tls: Getter for the #GoaMail:smtp-use-tls property.
 * @get_smtp_user_name: Getter for the #GoaMail:smtp-user-name property.
 * @get_imap_accept_ssl_errors: Getter for the #GoaMail:imap-accept-ssl-errors property.
 * @get_imap_use_ssl: Getter for the #GoaMail:imap-use-ssl property.
 * @get_name: Getter for the #GoaMail:name property.
 * @get_smtp_accept_ssl_errors: Getter for the #GoaMail:smtp-accept-ssl-errors property.
 * @get_smtp_use_auth: Getter for the #GoaMail:smtp-use-auth property.
 * @get_smtp_use_ssl: Getter for the #GoaMail:smtp-use-ssl property.
 * @get_smtp_auth_login: Getter for the #GoaMail:smtp-auth-login property.
 * @get_smtp_auth_plain: Getter for the #GoaMail:smtp-auth-plain property.
 * @get_smtp_auth_xoauth2: Getter for the #GoaMail:smtp-auth-xoauth2 property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>.
 */

typedef GoaMailIface GoaMailInterface;
G_DEFINE_INTERFACE (GoaMail, goa_mail, G_TYPE_OBJECT)

static void
goa_mail_default_init (GoaMailIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaMail:email-address:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("email-address", "EmailAddress", "EmailAddress", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.Name">"Name"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("name", "Name", "Name", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-supported:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapSupported">"ImapSupported"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("imap-supported", "ImapSupported", "ImapSupported", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-accept-ssl-errors:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapAcceptSslErrors">"ImapAcceptSslErrors"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("imap-accept-ssl-errors", "ImapAcceptSslErrors", "ImapAcceptSslErrors", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-host:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("imap-host", "ImapHost", "ImapHost", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-use-ssl:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseSsl">"ImapUseSsl"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("imap-use-ssl", "ImapUseSsl", "ImapUseSsl", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-use-tls:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseTls">"ImapUseTls"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("imap-use-tls", "ImapUseTls", "ImapUseTls", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:imap-user-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("imap-user-name", "ImapUserName", "ImapUserName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-supported:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpSupported">"SmtpSupported"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-supported", "SmtpSupported", "SmtpSupported", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-accept-ssl-errors:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAcceptSslErrors">"SmtpAcceptSslErrors"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-accept-ssl-errors", "SmtpAcceptSslErrors", "SmtpAcceptSslErrors", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-host:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("smtp-host", "SmtpHost", "SmtpHost", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-use-auth:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseAuth">"SmtpUseAuth"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-use-auth", "SmtpUseAuth", "SmtpUseAuth", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-auth-login:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthLogin">"SmtpAuthLogin"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.12.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-auth-login", "SmtpAuthLogin", "SmtpAuthLogin", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-auth-plain:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthPlain">"SmtpAuthPlain"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.12.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-auth-plain", "SmtpAuthPlain", "SmtpAuthPlain", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-auth-xoauth2:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthXoauth2">"SmtpAuthXoauth2"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.12.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-auth-xoauth2", "SmtpAuthXoauth2", "SmtpAuthXoauth2", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-use-ssl:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseSsl">"SmtpUseSsl"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-use-ssl", "SmtpUseSsl", "SmtpUseSsl", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-use-tls:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseTls">"SmtpUseTls"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("smtp-use-tls", "SmtpUseTls", "SmtpUseTls", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMail:smtp-user-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("smtp-user-name", "SmtpUserName", "SmtpUserName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_mail_get_email_address: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_email_address() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_email_address (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_email_address (object);
}

/**
 * goa_mail_dup_email_address: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_email_address (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "email-address", &value, NULL);
  return value;
}

/**
 * goa_mail_set_email_address: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.EmailAddress">"EmailAddress"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_email_address (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "email-address", value, NULL);
}

/**
 * goa_mail_get_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.Name">"Name"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_name() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.8.0
 */
const gchar *
goa_mail_get_name (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_name (object);
}

/**
 * goa_mail_dup_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.Name">"Name"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.8.0
 */
gchar *
goa_mail_dup_name (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "name", &value, NULL);
  return value;
}

/**
 * goa_mail_set_name: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.Name">"Name"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_mail_set_name (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "name", value, NULL);
}

/**
 * goa_mail_get_imap_supported: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapSupported">"ImapSupported"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_imap_supported (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_supported (object);
}

/**
 * goa_mail_set_imap_supported: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapSupported">"ImapSupported"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_supported (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "imap-supported", value, NULL);
}

/**
 * goa_mail_get_imap_accept_ssl_errors: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapAcceptSslErrors">"ImapAcceptSslErrors"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_mail_get_imap_accept_ssl_errors (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_accept_ssl_errors (object);
}

/**
 * goa_mail_set_imap_accept_ssl_errors: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapAcceptSslErrors">"ImapAcceptSslErrors"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_mail_set_imap_accept_ssl_errors (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "imap-accept-ssl-errors", value, NULL);
}

/**
 * goa_mail_get_imap_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_imap_host() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_imap_host (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_host (object);
}

/**
 * goa_mail_dup_imap_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_imap_host (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "imap-host", &value, NULL);
  return value;
}

/**
 * goa_mail_set_imap_host: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapHost">"ImapHost"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_host (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "imap-host", value, NULL);
}

/**
 * goa_mail_get_imap_use_ssl: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseSsl">"ImapUseSsl"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_mail_get_imap_use_ssl (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_use_ssl (object);
}

/**
 * goa_mail_set_imap_use_ssl: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseSsl">"ImapUseSsl"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_mail_set_imap_use_ssl (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "imap-use-ssl", value, NULL);
}

/**
 * goa_mail_get_imap_use_tls: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseTls">"ImapUseTls"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_imap_use_tls (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_use_tls (object);
}

/**
 * goa_mail_set_imap_use_tls: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUseTls">"ImapUseTls"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_use_tls (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "imap-use-tls", value, NULL);
}

/**
 * goa_mail_get_imap_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_imap_user_name() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_imap_user_name (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_imap_user_name (object);
}

/**
 * goa_mail_dup_imap_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_imap_user_name (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "imap-user-name", &value, NULL);
  return value;
}

/**
 * goa_mail_set_imap_user_name: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.ImapUserName">"ImapUserName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_imap_user_name (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "imap-user-name", value, NULL);
}

/**
 * goa_mail_get_smtp_supported: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpSupported">"SmtpSupported"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_smtp_supported (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_supported (object);
}

/**
 * goa_mail_set_smtp_supported: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpSupported">"SmtpSupported"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_supported (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-supported", value, NULL);
}

/**
 * goa_mail_get_smtp_accept_ssl_errors: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAcceptSslErrors">"SmtpAcceptSslErrors"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_mail_get_smtp_accept_ssl_errors (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_accept_ssl_errors (object);
}

/**
 * goa_mail_set_smtp_accept_ssl_errors: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAcceptSslErrors">"SmtpAcceptSslErrors"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_mail_set_smtp_accept_ssl_errors (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-accept-ssl-errors", value, NULL);
}

/**
 * goa_mail_get_smtp_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_smtp_host() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_smtp_host (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_host (object);
}

/**
 * goa_mail_dup_smtp_host: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_smtp_host (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "smtp-host", &value, NULL);
  return value;
}

/**
 * goa_mail_set_smtp_host: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpHost">"SmtpHost"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_host (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "smtp-host", value, NULL);
}

/**
 * goa_mail_get_smtp_use_auth: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseAuth">"SmtpUseAuth"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_mail_get_smtp_use_auth (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_use_auth (object);
}

/**
 * goa_mail_set_smtp_use_auth: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseAuth">"SmtpUseAuth"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_mail_set_smtp_use_auth (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-use-auth", value, NULL);
}

/**
 * goa_mail_get_smtp_auth_login: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthLogin">"SmtpAuthLogin"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.12.0
 */
gboolean 
goa_mail_get_smtp_auth_login (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_auth_login (object);
}

/**
 * goa_mail_set_smtp_auth_login: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthLogin">"SmtpAuthLogin"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.12.0
 */
void
goa_mail_set_smtp_auth_login (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-auth-login", value, NULL);
}

/**
 * goa_mail_get_smtp_auth_plain: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthPlain">"SmtpAuthPlain"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.12.0
 */
gboolean 
goa_mail_get_smtp_auth_plain (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_auth_plain (object);
}

/**
 * goa_mail_set_smtp_auth_plain: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthPlain">"SmtpAuthPlain"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.12.0
 */
void
goa_mail_set_smtp_auth_plain (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-auth-plain", value, NULL);
}

/**
 * goa_mail_get_smtp_auth_xoauth2: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthXoauth2">"SmtpAuthXoauth2"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.12.0
 */
gboolean 
goa_mail_get_smtp_auth_xoauth2 (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_auth_xoauth2 (object);
}

/**
 * goa_mail_set_smtp_auth_xoauth2: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpAuthXoauth2">"SmtpAuthXoauth2"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.12.0
 */
void
goa_mail_set_smtp_auth_xoauth2 (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-auth-xoauth2", value, NULL);
}

/**
 * goa_mail_get_smtp_use_ssl: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseSsl">"SmtpUseSsl"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_mail_get_smtp_use_ssl (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_use_ssl (object);
}

/**
 * goa_mail_set_smtp_use_ssl: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseSsl">"SmtpUseSsl"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_mail_set_smtp_use_ssl (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-use-ssl", value, NULL);
}

/**
 * goa_mail_get_smtp_use_tls: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseTls">"SmtpUseTls"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
goa_mail_get_smtp_use_tls (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_use_tls (object);
}

/**
 * goa_mail_set_smtp_use_tls: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUseTls">"SmtpUseTls"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_use_tls (GoaMail *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "smtp-use-tls", value, NULL);
}

/**
 * goa_mail_get_smtp_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_mail_dup_smtp_user_name() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
goa_mail_get_smtp_user_name (GoaMail *object)
{
  return GOA_MAIL_GET_IFACE (object)->get_smtp_user_name (object);
}

/**
 * goa_mail_dup_smtp_user_name: (skip)
 * @object: A #GoaMail.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
goa_mail_dup_smtp_user_name (GoaMail *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "smtp-user-name", &value, NULL);
  return value;
}

/**
 * goa_mail_set_smtp_user_name: (skip)
 * @object: A #GoaMail.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Mail.SmtpUserName">"SmtpUserName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
goa_mail_set_smtp_user_name (GoaMail *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "smtp-user-name", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaMailProxy:
 *
 * The #GoaMailProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaMailProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMailProxy.
 */

struct _GoaMailProxyPrivate
{
  GData *qdata;
};

static void goa_mail_proxy_iface_init (GoaMailIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMailProxy, goa_mail_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaMailProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAIL, goa_mail_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMailProxy, goa_mail_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAIL, goa_mail_proxy_iface_init))

#endif
static void
goa_mail_proxy_finalize (GObject *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_mail_proxy_parent_class)->finalize (object);
}

static void
goa_mail_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 18);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_mail_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_mail_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Mail: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_mail_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 18);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_mail_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Mail", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_mail_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_mail_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MAIL);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MAIL);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_mail_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
goa_mail_proxy_get_email_address (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "EmailAddress");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_name (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Name");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_imap_supported (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapSupported");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_imap_accept_ssl_errors (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapAcceptSslErrors");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_imap_host (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapHost");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_imap_use_ssl (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapUseSsl");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_imap_use_tls (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapUseTls");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_imap_user_name (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ImapUserName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_supported (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpSupported");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_accept_ssl_errors (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpAcceptSslErrors");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_smtp_host (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpHost");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_use_auth (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpUseAuth");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_auth_login (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpAuthLogin");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_auth_plain (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpAuthPlain");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_auth_xoauth2 (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpAuthXoauth2");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_use_ssl (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpUseSsl");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
goa_mail_proxy_get_smtp_use_tls (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpUseTls");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_mail_proxy_get_smtp_user_name (GoaMail *object)
{
  GoaMailProxy *proxy = GOA_MAIL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SmtpUserName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_mail_proxy_init (GoaMailProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_mail_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MAIL_PROXY, GoaMailProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_mail_interface_info ());
}

static void
goa_mail_proxy_class_init (GoaMailProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_mail_proxy_finalize;
  gobject_class->get_property = goa_mail_proxy_get_property;
  gobject_class->set_property = goa_mail_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_mail_proxy_g_signal;
  proxy_class->g_properties_changed = goa_mail_proxy_g_properties_changed;

  goa_mail_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMailProxyPrivate));
#endif
}

static void
goa_mail_proxy_iface_init (GoaMailIface *iface)
{
  iface->get_email_address = goa_mail_proxy_get_email_address;
  iface->get_name = goa_mail_proxy_get_name;
  iface->get_imap_supported = goa_mail_proxy_get_imap_supported;
  iface->get_imap_accept_ssl_errors = goa_mail_proxy_get_imap_accept_ssl_errors;
  iface->get_imap_host = goa_mail_proxy_get_imap_host;
  iface->get_imap_use_ssl = goa_mail_proxy_get_imap_use_ssl;
  iface->get_imap_use_tls = goa_mail_proxy_get_imap_use_tls;
  iface->get_imap_user_name = goa_mail_proxy_get_imap_user_name;
  iface->get_smtp_supported = goa_mail_proxy_get_smtp_supported;
  iface->get_smtp_accept_ssl_errors = goa_mail_proxy_get_smtp_accept_ssl_errors;
  iface->get_smtp_host = goa_mail_proxy_get_smtp_host;
  iface->get_smtp_use_auth = goa_mail_proxy_get_smtp_use_auth;
  iface->get_smtp_auth_login = goa_mail_proxy_get_smtp_auth_login;
  iface->get_smtp_auth_plain = goa_mail_proxy_get_smtp_auth_plain;
  iface->get_smtp_auth_xoauth2 = goa_mail_proxy_get_smtp_auth_xoauth2;
  iface->get_smtp_use_ssl = goa_mail_proxy_get_smtp_use_ssl;
  iface->get_smtp_use_tls = goa_mail_proxy_get_smtp_use_tls;
  iface->get_smtp_user_name = goa_mail_proxy_get_smtp_user_name;
}

/**
 * goa_mail_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_mail_proxy_new_finish() to get the result of the operation.
 *
 * See goa_mail_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_mail_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MAIL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
}

/**
 * goa_mail_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_mail_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_mail_proxy_new().
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}

/**
 * goa_mail_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_mail_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MAIL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}


/**
 * goa_mail_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_mail_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_mail_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_mail_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_mail_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MAIL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
}

/**
 * goa_mail_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_mail_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_mail_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}

/**
 * goa_mail_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_mail_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_mail_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMailProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaMail *
goa_mail_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MAIL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Mail", NULL);
  if (ret != NULL)
    return GOA_MAIL (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaMailSkeleton:
 *
 * The #GoaMailSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaMailSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMailSkeleton.
 */

struct _GoaMailSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_mail_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MAIL);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MAIL);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_mail_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_mail_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_mail_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_mail_skeleton_vtable =
{
  _goa_mail_skeleton_handle_method_call,
  _goa_mail_skeleton_handle_get_property,
  _goa_mail_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_mail_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_mail_interface_info ();
}

static GDBusInterfaceVTable *
goa_mail_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_mail_skeleton_vtable;
}

static GVariant *
goa_mail_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_mail_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_mail_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_mail_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_mail_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Mail", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_mail_emit_changed (gpointer user_data);

static void
goa_mail_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_mail_emit_changed (skeleton);
}

static void goa_mail_skeleton_iface_init (GoaMailIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMailSkeleton, goa_mail_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaMailSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAIL, goa_mail_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMailSkeleton, goa_mail_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAIL, goa_mail_skeleton_iface_init))

#endif
static void
goa_mail_skeleton_finalize (GObject *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  guint n;
  for (n = 0; n < 18; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_mail_skeleton_parent_class)->finalize (object);
}

static void
goa_mail_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 18);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_mail_emit_changed (gpointer user_data)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Mail",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_mail_schedule_emit_changed (GoaMailSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_mail_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_mail_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_mail_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_mail_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 18);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_mail_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_mail_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_mail_skeleton_init (GoaMailSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_mail_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MAIL_SKELETON, GoaMailSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 18);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[8], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[9], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[10], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[11], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[12], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[13], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[14], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[15], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[16], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[17], G_TYPE_STRING);
}

static const gchar *
goa_mail_skeleton_get_email_address (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_name (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_imap_supported (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_imap_accept_ssl_errors (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_imap_host (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_imap_use_ssl (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_imap_use_tls (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_imap_user_name (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_supported (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[8]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_accept_ssl_errors (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[9]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_smtp_host (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[10]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_use_auth (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[11]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_auth_login (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[12]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_auth_plain (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[13]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_auth_xoauth2 (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[14]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_use_ssl (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[15]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
goa_mail_skeleton_get_smtp_use_tls (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[16]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_mail_skeleton_get_smtp_user_name (GoaMail *object)
{
  GoaMailSkeleton *skeleton = GOA_MAIL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[17]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_mail_skeleton_class_init (GoaMailSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_mail_skeleton_finalize;
  gobject_class->get_property = goa_mail_skeleton_get_property;
  gobject_class->set_property = goa_mail_skeleton_set_property;
  gobject_class->notify       = goa_mail_skeleton_notify;


  goa_mail_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_mail_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_mail_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_mail_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_mail_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMailSkeletonPrivate));
#endif
}

static void
goa_mail_skeleton_iface_init (GoaMailIface *iface)
{
  iface->get_email_address = goa_mail_skeleton_get_email_address;
  iface->get_name = goa_mail_skeleton_get_name;
  iface->get_imap_supported = goa_mail_skeleton_get_imap_supported;
  iface->get_imap_accept_ssl_errors = goa_mail_skeleton_get_imap_accept_ssl_errors;
  iface->get_imap_host = goa_mail_skeleton_get_imap_host;
  iface->get_imap_use_ssl = goa_mail_skeleton_get_imap_use_ssl;
  iface->get_imap_use_tls = goa_mail_skeleton_get_imap_use_tls;
  iface->get_imap_user_name = goa_mail_skeleton_get_imap_user_name;
  iface->get_smtp_supported = goa_mail_skeleton_get_smtp_supported;
  iface->get_smtp_accept_ssl_errors = goa_mail_skeleton_get_smtp_accept_ssl_errors;
  iface->get_smtp_host = goa_mail_skeleton_get_smtp_host;
  iface->get_smtp_use_auth = goa_mail_skeleton_get_smtp_use_auth;
  iface->get_smtp_auth_login = goa_mail_skeleton_get_smtp_auth_login;
  iface->get_smtp_auth_plain = goa_mail_skeleton_get_smtp_auth_plain;
  iface->get_smtp_auth_xoauth2 = goa_mail_skeleton_get_smtp_auth_xoauth2;
  iface->get_smtp_use_ssl = goa_mail_skeleton_get_smtp_use_ssl;
  iface->get_smtp_use_tls = goa_mail_skeleton_get_smtp_use_tls;
  iface->get_smtp_user_name = goa_mail_skeleton_get_smtp_user_name;
}

/**
 * goa_mail_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>.
 *
 * Returns: (transfer full) (type GoaMailSkeleton): The skeleton object.
 */
GoaMail *
goa_mail_skeleton_new (void)
{
  return GOA_MAIL (g_object_new (GOA_TYPE_MAIL_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Calendar
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaCalendar
 * @title: GoaCalendar
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Calendar D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Calendar ---- */

static const _ExtendedGDBusPropertyInfo _goa_calendar_property_info_accept_ssl_errors =
{
  {
    -1,
    (gchar *) "AcceptSslErrors",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "accept-ssl-errors",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_calendar_property_info_uri =
{
  {
    -1,
    (gchar *) "Uri",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "uri",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_calendar_property_info_pointers[] =
{
  &_goa_calendar_property_info_accept_ssl_errors.parent_struct,
  &_goa_calendar_property_info_uri.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_calendar_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Calendar",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_calendar_property_info_pointers,
    NULL
  },
  "calendar",
};


/**
 * goa_calendar_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_calendar_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct;
}

/**
 * goa_calendar_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaCalendar interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_calendar_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "accept-ssl-errors");
  g_object_class_override_property (klass, property_id_begin++, "uri");
  return property_id_begin - 1;
}



/**
 * GoaCalendar:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>.
 */

/**
 * GoaCalendarIface:
 * @parent_iface: The parent interface.
 * @get_accept_ssl_errors: Getter for the #GoaCalendar:accept-ssl-errors property.
 * @get_uri: Getter for the #GoaCalendar:uri property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>.
 */

typedef GoaCalendarIface GoaCalendarInterface;
G_DEFINE_INTERFACE (GoaCalendar, goa_calendar, G_TYPE_OBJECT)

static void
goa_calendar_default_init (GoaCalendarIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaCalendar:accept-ssl-errors:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.AcceptSslErrors">"AcceptSslErrors"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("accept-ssl-errors", "AcceptSslErrors", "AcceptSslErrors", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaCalendar:uri:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.Uri">"Uri"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("uri", "Uri", "Uri", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_calendar_get_accept_ssl_errors: (skip)
 * @object: A #GoaCalendar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_calendar_get_accept_ssl_errors (GoaCalendar *object)
{
  return GOA_CALENDAR_GET_IFACE (object)->get_accept_ssl_errors (object);
}

/**
 * goa_calendar_set_accept_ssl_errors: (skip)
 * @object: A #GoaCalendar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_calendar_set_accept_ssl_errors (GoaCalendar *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "accept-ssl-errors", value, NULL);
}

/**
 * goa_calendar_get_uri: (skip)
 * @object: A #GoaCalendar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.Uri">"Uri"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_calendar_dup_uri() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.8.0
 */
const gchar *
goa_calendar_get_uri (GoaCalendar *object)
{
  return GOA_CALENDAR_GET_IFACE (object)->get_uri (object);
}

/**
 * goa_calendar_dup_uri: (skip)
 * @object: A #GoaCalendar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.Uri">"Uri"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.8.0
 */
gchar *
goa_calendar_dup_uri (GoaCalendar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "uri", &value, NULL);
  return value;
}

/**
 * goa_calendar_set_uri: (skip)
 * @object: A #GoaCalendar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Calendar.Uri">"Uri"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_calendar_set_uri (GoaCalendar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "uri", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaCalendarProxy:
 *
 * The #GoaCalendarProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaCalendarProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaCalendarProxy.
 */

struct _GoaCalendarProxyPrivate
{
  GData *qdata;
};

static void goa_calendar_proxy_iface_init (GoaCalendarIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaCalendarProxy, goa_calendar_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaCalendarProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CALENDAR, goa_calendar_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaCalendarProxy, goa_calendar_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CALENDAR, goa_calendar_proxy_iface_init))

#endif
static void
goa_calendar_proxy_finalize (GObject *object)
{
  GoaCalendarProxy *proxy = GOA_CALENDAR_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_calendar_proxy_parent_class)->finalize (object);
}

static void
goa_calendar_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_calendar_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_calendar_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Calendar: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_calendar_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_calendar_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Calendar", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_calendar_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_calendar_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_CALENDAR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CALENDAR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_calendar_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaCalendarProxy *proxy = GOA_CALENDAR_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
goa_calendar_proxy_get_accept_ssl_errors (GoaCalendar *object)
{
  GoaCalendarProxy *proxy = GOA_CALENDAR_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AcceptSslErrors");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_calendar_proxy_get_uri (GoaCalendar *object)
{
  GoaCalendarProxy *proxy = GOA_CALENDAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Uri");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_calendar_proxy_init (GoaCalendarProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_calendar_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_CALENDAR_PROXY, GoaCalendarProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_calendar_interface_info ());
}

static void
goa_calendar_proxy_class_init (GoaCalendarProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_calendar_proxy_finalize;
  gobject_class->get_property = goa_calendar_proxy_get_property;
  gobject_class->set_property = goa_calendar_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_calendar_proxy_g_signal;
  proxy_class->g_properties_changed = goa_calendar_proxy_g_properties_changed;

  goa_calendar_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaCalendarProxyPrivate));
#endif
}

static void
goa_calendar_proxy_iface_init (GoaCalendarIface *iface)
{
  iface->get_accept_ssl_errors = goa_calendar_proxy_get_accept_ssl_errors;
  iface->get_uri = goa_calendar_proxy_get_uri;
}

/**
 * goa_calendar_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_calendar_proxy_new_finish() to get the result of the operation.
 *
 * See goa_calendar_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_calendar_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CALENDAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
}

/**
 * goa_calendar_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_calendar_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_calendar_proxy_new().
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}

/**
 * goa_calendar_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_calendar_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CALENDAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}


/**
 * goa_calendar_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_calendar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_calendar_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_calendar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_calendar_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CALENDAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
}

/**
 * goa_calendar_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_calendar_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_calendar_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}

/**
 * goa_calendar_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_calendar_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_calendar_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaCalendarProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaCalendar *
goa_calendar_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CALENDAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Calendar", NULL);
  if (ret != NULL)
    return GOA_CALENDAR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaCalendarSkeleton:
 *
 * The #GoaCalendarSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaCalendarSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaCalendarSkeleton.
 */

struct _GoaCalendarSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_calendar_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_CALENDAR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CALENDAR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_calendar_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_calendar_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_calendar_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_calendar_skeleton_vtable =
{
  _goa_calendar_skeleton_handle_method_call,
  _goa_calendar_skeleton_handle_get_property,
  _goa_calendar_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_calendar_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_calendar_interface_info ();
}

static GDBusInterfaceVTable *
goa_calendar_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_calendar_skeleton_vtable;
}

static GVariant *
goa_calendar_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_calendar_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_calendar_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_calendar_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_calendar_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Calendar", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_calendar_emit_changed (gpointer user_data);

static void
goa_calendar_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_calendar_emit_changed (skeleton);
}

static void goa_calendar_skeleton_iface_init (GoaCalendarIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaCalendarSkeleton, goa_calendar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaCalendarSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CALENDAR, goa_calendar_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaCalendarSkeleton, goa_calendar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CALENDAR, goa_calendar_skeleton_iface_init))

#endif
static void
goa_calendar_skeleton_finalize (GObject *object)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_calendar_skeleton_parent_class)->finalize (object);
}

static void
goa_calendar_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_calendar_emit_changed (gpointer user_data)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Calendar",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_calendar_schedule_emit_changed (GoaCalendarSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_calendar_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_calendar_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_calendar_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_calendar_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_calendar_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_calendar_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_calendar_skeleton_init (GoaCalendarSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_calendar_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_CALENDAR_SKELETON, GoaCalendarSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gboolean 
goa_calendar_skeleton_get_accept_ssl_errors (GoaCalendar *object)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_calendar_skeleton_get_uri (GoaCalendar *object)
{
  GoaCalendarSkeleton *skeleton = GOA_CALENDAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_calendar_skeleton_class_init (GoaCalendarSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_calendar_skeleton_finalize;
  gobject_class->get_property = goa_calendar_skeleton_get_property;
  gobject_class->set_property = goa_calendar_skeleton_set_property;
  gobject_class->notify       = goa_calendar_skeleton_notify;


  goa_calendar_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_calendar_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_calendar_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_calendar_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_calendar_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaCalendarSkeletonPrivate));
#endif
}

static void
goa_calendar_skeleton_iface_init (GoaCalendarIface *iface)
{
  iface->get_accept_ssl_errors = goa_calendar_skeleton_get_accept_ssl_errors;
  iface->get_uri = goa_calendar_skeleton_get_uri;
}

/**
 * goa_calendar_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>.
 *
 * Returns: (transfer full) (type GoaCalendarSkeleton): The skeleton object.
 */
GoaCalendar *
goa_calendar_skeleton_new (void)
{
  return GOA_CALENDAR (g_object_new (GOA_TYPE_CALENDAR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Contacts
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaContacts
 * @title: GoaContacts
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Contacts D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Contacts ---- */

static const _ExtendedGDBusPropertyInfo _goa_contacts_property_info_accept_ssl_errors =
{
  {
    -1,
    (gchar *) "AcceptSslErrors",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "accept-ssl-errors",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_contacts_property_info_uri =
{
  {
    -1,
    (gchar *) "Uri",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "uri",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_contacts_property_info_pointers[] =
{
  &_goa_contacts_property_info_accept_ssl_errors.parent_struct,
  &_goa_contacts_property_info_uri.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_contacts_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Contacts",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_contacts_property_info_pointers,
    NULL
  },
  "contacts",
};


/**
 * goa_contacts_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_contacts_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct;
}

/**
 * goa_contacts_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaContacts interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_contacts_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "accept-ssl-errors");
  g_object_class_override_property (klass, property_id_begin++, "uri");
  return property_id_begin - 1;
}



/**
 * GoaContacts:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>.
 */

/**
 * GoaContactsIface:
 * @parent_iface: The parent interface.
 * @get_accept_ssl_errors: Getter for the #GoaContacts:accept-ssl-errors property.
 * @get_uri: Getter for the #GoaContacts:uri property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>.
 */

typedef GoaContactsIface GoaContactsInterface;
G_DEFINE_INTERFACE (GoaContacts, goa_contacts, G_TYPE_OBJECT)

static void
goa_contacts_default_init (GoaContactsIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaContacts:accept-ssl-errors:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.AcceptSslErrors">"AcceptSslErrors"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("accept-ssl-errors", "AcceptSslErrors", "AcceptSslErrors", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaContacts:uri:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.Uri">"Uri"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("uri", "Uri", "Uri", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_contacts_get_accept_ssl_errors: (skip)
 * @object: A #GoaContacts.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_contacts_get_accept_ssl_errors (GoaContacts *object)
{
  return GOA_CONTACTS_GET_IFACE (object)->get_accept_ssl_errors (object);
}

/**
 * goa_contacts_set_accept_ssl_errors: (skip)
 * @object: A #GoaContacts.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_contacts_set_accept_ssl_errors (GoaContacts *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "accept-ssl-errors", value, NULL);
}

/**
 * goa_contacts_get_uri: (skip)
 * @object: A #GoaContacts.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.Uri">"Uri"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_contacts_dup_uri() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.8.0
 */
const gchar *
goa_contacts_get_uri (GoaContacts *object)
{
  return GOA_CONTACTS_GET_IFACE (object)->get_uri (object);
}

/**
 * goa_contacts_dup_uri: (skip)
 * @object: A #GoaContacts.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.Uri">"Uri"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.8.0
 */
gchar *
goa_contacts_dup_uri (GoaContacts *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "uri", &value, NULL);
  return value;
}

/**
 * goa_contacts_set_uri: (skip)
 * @object: A #GoaContacts.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Contacts.Uri">"Uri"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_contacts_set_uri (GoaContacts *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "uri", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaContactsProxy:
 *
 * The #GoaContactsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaContactsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaContactsProxy.
 */

struct _GoaContactsProxyPrivate
{
  GData *qdata;
};

static void goa_contacts_proxy_iface_init (GoaContactsIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaContactsProxy, goa_contacts_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaContactsProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CONTACTS, goa_contacts_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaContactsProxy, goa_contacts_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CONTACTS, goa_contacts_proxy_iface_init))

#endif
static void
goa_contacts_proxy_finalize (GObject *object)
{
  GoaContactsProxy *proxy = GOA_CONTACTS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_contacts_proxy_parent_class)->finalize (object);
}

static void
goa_contacts_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_contacts_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_contacts_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Contacts: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_contacts_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_contacts_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Contacts", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_contacts_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_contacts_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_CONTACTS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CONTACTS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_contacts_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaContactsProxy *proxy = GOA_CONTACTS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
goa_contacts_proxy_get_accept_ssl_errors (GoaContacts *object)
{
  GoaContactsProxy *proxy = GOA_CONTACTS_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AcceptSslErrors");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_contacts_proxy_get_uri (GoaContacts *object)
{
  GoaContactsProxy *proxy = GOA_CONTACTS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Uri");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_contacts_proxy_init (GoaContactsProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_contacts_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_CONTACTS_PROXY, GoaContactsProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_contacts_interface_info ());
}

static void
goa_contacts_proxy_class_init (GoaContactsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_contacts_proxy_finalize;
  gobject_class->get_property = goa_contacts_proxy_get_property;
  gobject_class->set_property = goa_contacts_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_contacts_proxy_g_signal;
  proxy_class->g_properties_changed = goa_contacts_proxy_g_properties_changed;

  goa_contacts_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaContactsProxyPrivate));
#endif
}

static void
goa_contacts_proxy_iface_init (GoaContactsIface *iface)
{
  iface->get_accept_ssl_errors = goa_contacts_proxy_get_accept_ssl_errors;
  iface->get_uri = goa_contacts_proxy_get_uri;
}

/**
 * goa_contacts_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_contacts_proxy_new_finish() to get the result of the operation.
 *
 * See goa_contacts_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_contacts_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CONTACTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
}

/**
 * goa_contacts_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_contacts_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_contacts_proxy_new().
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}

/**
 * goa_contacts_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_contacts_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CONTACTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}


/**
 * goa_contacts_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_contacts_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_contacts_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_contacts_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_contacts_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CONTACTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
}

/**
 * goa_contacts_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_contacts_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_contacts_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}

/**
 * goa_contacts_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_contacts_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_contacts_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaContactsProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaContacts *
goa_contacts_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CONTACTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Contacts", NULL);
  if (ret != NULL)
    return GOA_CONTACTS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaContactsSkeleton:
 *
 * The #GoaContactsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaContactsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaContactsSkeleton.
 */

struct _GoaContactsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_contacts_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_CONTACTS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CONTACTS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_contacts_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_contacts_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_contacts_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_contacts_skeleton_vtable =
{
  _goa_contacts_skeleton_handle_method_call,
  _goa_contacts_skeleton_handle_get_property,
  _goa_contacts_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_contacts_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_contacts_interface_info ();
}

static GDBusInterfaceVTable *
goa_contacts_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_contacts_skeleton_vtable;
}

static GVariant *
goa_contacts_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_contacts_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_contacts_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_contacts_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_contacts_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Contacts", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_contacts_emit_changed (gpointer user_data);

static void
goa_contacts_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_contacts_emit_changed (skeleton);
}

static void goa_contacts_skeleton_iface_init (GoaContactsIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaContactsSkeleton, goa_contacts_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaContactsSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CONTACTS, goa_contacts_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaContactsSkeleton, goa_contacts_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CONTACTS, goa_contacts_skeleton_iface_init))

#endif
static void
goa_contacts_skeleton_finalize (GObject *object)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_contacts_skeleton_parent_class)->finalize (object);
}

static void
goa_contacts_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_contacts_emit_changed (gpointer user_data)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Contacts",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_contacts_schedule_emit_changed (GoaContactsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_contacts_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_contacts_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_contacts_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_contacts_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_contacts_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_contacts_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_contacts_skeleton_init (GoaContactsSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_contacts_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_CONTACTS_SKELETON, GoaContactsSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gboolean 
goa_contacts_skeleton_get_accept_ssl_errors (GoaContacts *object)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_contacts_skeleton_get_uri (GoaContacts *object)
{
  GoaContactsSkeleton *skeleton = GOA_CONTACTS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_contacts_skeleton_class_init (GoaContactsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_contacts_skeleton_finalize;
  gobject_class->get_property = goa_contacts_skeleton_get_property;
  gobject_class->set_property = goa_contacts_skeleton_set_property;
  gobject_class->notify       = goa_contacts_skeleton_notify;


  goa_contacts_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_contacts_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_contacts_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_contacts_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_contacts_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaContactsSkeletonPrivate));
#endif
}

static void
goa_contacts_skeleton_iface_init (GoaContactsIface *iface)
{
  iface->get_accept_ssl_errors = goa_contacts_skeleton_get_accept_ssl_errors;
  iface->get_uri = goa_contacts_skeleton_get_uri;
}

/**
 * goa_contacts_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>.
 *
 * Returns: (transfer full) (type GoaContactsSkeleton): The skeleton object.
 */
GoaContacts *
goa_contacts_skeleton_new (void)
{
  return GOA_CONTACTS (g_object_new (GOA_TYPE_CONTACTS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Chat
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaChat
 * @title: GoaChat
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Chat D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Chat ---- */

static const _ExtendedGDBusInterfaceInfo _goa_chat_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Chat",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "chat",
};


/**
 * goa_chat_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
goa_chat_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct;
}

/**
 * goa_chat_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaChat interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
goa_chat_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaChat:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>.
 */

/**
 * GoaChatIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>.
 */

typedef GoaChatIface GoaChatInterface;
G_DEFINE_INTERFACE (GoaChat, goa_chat, G_TYPE_OBJECT)

static void
goa_chat_default_init (GoaChatIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaChatProxy:
 *
 * The #GoaChatProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaChatProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaChatProxy.
 */

struct _GoaChatProxyPrivate
{
  GData *qdata;
};

static void goa_chat_proxy_iface_init (GoaChatIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaChatProxy, goa_chat_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaChatProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CHAT, goa_chat_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaChatProxy, goa_chat_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CHAT, goa_chat_proxy_iface_init))

#endif
static void
goa_chat_proxy_finalize (GObject *object)
{
  GoaChatProxy *proxy = GOA_CHAT_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_chat_proxy_parent_class)->finalize (object);
}

static void
goa_chat_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_chat_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_chat_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_CHAT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CHAT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_chat_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaChatProxy *proxy = GOA_CHAT_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_chat_proxy_init (GoaChatProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_chat_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_CHAT_PROXY, GoaChatProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_chat_interface_info ());
}

static void
goa_chat_proxy_class_init (GoaChatProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_chat_proxy_finalize;
  gobject_class->get_property = goa_chat_proxy_get_property;
  gobject_class->set_property = goa_chat_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_chat_proxy_g_signal;
  proxy_class->g_properties_changed = goa_chat_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaChatProxyPrivate));
#endif
}

static void
goa_chat_proxy_iface_init (GoaChatIface *iface)
{
}

/**
 * goa_chat_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_chat_proxy_new_finish() to get the result of the operation.
 *
 * See goa_chat_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_chat_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CHAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
}

/**
 * goa_chat_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_chat_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_chat_proxy_new().
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}

/**
 * goa_chat_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_chat_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CHAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}


/**
 * goa_chat_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_chat_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_chat_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_chat_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_chat_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_CHAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
}

/**
 * goa_chat_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_chat_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_chat_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}

/**
 * goa_chat_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_chat_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_chat_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaChatProxy): The constructed proxy object or %NULL if @error is set.
 */
GoaChat *
goa_chat_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_CHAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Chat", NULL);
  if (ret != NULL)
    return GOA_CHAT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaChatSkeleton:
 *
 * The #GoaChatSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaChatSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaChatSkeleton.
 */

struct _GoaChatSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_chat_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_CHAT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_CHAT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_chat_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_chat_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_chat_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_chat_skeleton_vtable =
{
  _goa_chat_skeleton_handle_method_call,
  _goa_chat_skeleton_handle_get_property,
  _goa_chat_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_chat_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_chat_interface_info ();
}

static GDBusInterfaceVTable *
goa_chat_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_chat_skeleton_vtable;
}

static GVariant *
goa_chat_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_chat_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_chat_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_chat_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_chat_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Chat", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_chat_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_chat_skeleton_iface_init (GoaChatIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaChatSkeleton, goa_chat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaChatSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CHAT, goa_chat_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaChatSkeleton, goa_chat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_CHAT, goa_chat_skeleton_iface_init))

#endif
static void
goa_chat_skeleton_finalize (GObject *object)
{
  GoaChatSkeleton *skeleton = GOA_CHAT_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_chat_skeleton_parent_class)->finalize (object);
}

static void
goa_chat_skeleton_init (GoaChatSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_chat_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_CHAT_SKELETON, GoaChatSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_chat_skeleton_class_init (GoaChatSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_chat_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_chat_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_chat_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_chat_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_chat_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaChatSkeletonPrivate));
#endif
}

static void
goa_chat_skeleton_iface_init (GoaChatIface *iface)
{
}

/**
 * goa_chat_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>.
 *
 * Returns: (transfer full) (type GoaChatSkeleton): The skeleton object.
 */
GoaChat *
goa_chat_skeleton_new (void)
{
  return GOA_CHAT (g_object_new (GOA_TYPE_CHAT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Documents
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaDocuments
 * @title: GoaDocuments
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Documents D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Documents ---- */

static const GDBusAnnotationInfo _goa_documents_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _goa_documents_annotation_info_pointers[] =
{
  &_goa_documents_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_documents_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Documents",
    NULL,
    NULL,
    NULL,
    (GDBusAnnotationInfo **) &_goa_documents_annotation_info_pointers
  },
  "documents",
};


/**
 * goa_documents_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GDBusInterfaceInfo *
goa_documents_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct;
}

/**
 * goa_documents_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaDocuments interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
guint
goa_documents_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaDocuments:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaDocumentsIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

typedef GoaDocumentsIface GoaDocumentsInterface;
G_DEFINE_INTERFACE (GoaDocuments, goa_documents, G_TYPE_OBJECT)

static void
goa_documents_default_init (GoaDocumentsIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaDocumentsProxy:
 *
 * The #GoaDocumentsProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaDocumentsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaDocumentsProxy.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _GoaDocumentsProxyPrivate
{
  GData *qdata;
};

static void goa_documents_proxy_iface_init (GoaDocumentsIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaDocumentsProxy, goa_documents_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaDocumentsProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_DOCUMENTS, goa_documents_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaDocumentsProxy, goa_documents_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_DOCUMENTS, goa_documents_proxy_iface_init))

#endif
static void
goa_documents_proxy_finalize (GObject *object)
{
  GoaDocumentsProxy *proxy = GOA_DOCUMENTS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_documents_proxy_parent_class)->finalize (object);
}

static void
goa_documents_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_documents_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_documents_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_DOCUMENTS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_DOCUMENTS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_documents_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaDocumentsProxy *proxy = GOA_DOCUMENTS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_documents_proxy_init (GoaDocumentsProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_documents_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_DOCUMENTS_PROXY, GoaDocumentsProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_documents_interface_info ());
}

static void
goa_documents_proxy_class_init (GoaDocumentsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_documents_proxy_finalize;
  gobject_class->get_property = goa_documents_proxy_get_property;
  gobject_class->set_property = goa_documents_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_documents_proxy_g_signal;
  proxy_class->g_properties_changed = goa_documents_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaDocumentsProxyPrivate));
#endif
}

static void
goa_documents_proxy_iface_init (GoaDocumentsIface *iface)
{
}

/**
 * goa_documents_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_documents_proxy_new_finish() to get the result of the operation.
 *
 * See goa_documents_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
goa_documents_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_DOCUMENTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
}

/**
 * goa_documents_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_documents_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_documents_proxy_new().
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *
goa_documents_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}

/**
 * goa_documents_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_documents_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *
goa_documents_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_DOCUMENTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}


/**
 * goa_documents_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_documents_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_documents_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_documents_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
goa_documents_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_DOCUMENTS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
}

/**
 * goa_documents_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_documents_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_documents_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *
goa_documents_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}

/**
 * goa_documents_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_documents_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_documents_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaDocumentsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *
goa_documents_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_DOCUMENTS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Documents", NULL);
  if (ret != NULL)
    return GOA_DOCUMENTS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaDocumentsSkeleton:
 *
 * The #GoaDocumentsSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaDocumentsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaDocumentsSkeleton.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _GoaDocumentsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_documents_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_DOCUMENTS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_DOCUMENTS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_documents_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_documents_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_documents_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_documents_skeleton_vtable =
{
  _goa_documents_skeleton_handle_method_call,
  _goa_documents_skeleton_handle_get_property,
  _goa_documents_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_documents_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_documents_interface_info ();
}

static GDBusInterfaceVTable *
goa_documents_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_documents_skeleton_vtable;
}

static GVariant *
goa_documents_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_documents_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_documents_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_documents_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_documents_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Documents", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_documents_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_documents_skeleton_iface_init (GoaDocumentsIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaDocumentsSkeleton, goa_documents_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaDocumentsSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_DOCUMENTS, goa_documents_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaDocumentsSkeleton, goa_documents_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_DOCUMENTS, goa_documents_skeleton_iface_init))

#endif
static void
goa_documents_skeleton_finalize (GObject *object)
{
  GoaDocumentsSkeleton *skeleton = GOA_DOCUMENTS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_documents_skeleton_parent_class)->finalize (object);
}

static void
goa_documents_skeleton_init (GoaDocumentsSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_documents_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_DOCUMENTS_SKELETON, GoaDocumentsSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_documents_skeleton_class_init (GoaDocumentsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_documents_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_documents_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_documents_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_documents_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_documents_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaDocumentsSkeletonPrivate));
#endif
}

static void
goa_documents_skeleton_iface_init (GoaDocumentsIface *iface)
{
}

/**
 * goa_documents_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>.
 *
 * Returns: (transfer full) (type GoaDocumentsSkeleton): The skeleton object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *
goa_documents_skeleton_new (void)
{
  return GOA_DOCUMENTS (g_object_new (GOA_TYPE_DOCUMENTS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Maps
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaMaps
 * @title: GoaMaps
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Maps D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Maps ---- */

static const _ExtendedGDBusInterfaceInfo _goa_maps_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Maps",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "maps",
};


/**
 * goa_maps_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.14.0
 */
GDBusInterfaceInfo *
goa_maps_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_maps_interface_info.parent_struct;
}

/**
 * goa_maps_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaMaps interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.14.0
 */
guint
goa_maps_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaMaps:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link>.
 *
 * Since: 3.14.0
 */

/**
 * GoaMapsIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link>.
 *
 * Since: 3.14.0
 */

typedef GoaMapsIface GoaMapsInterface;
G_DEFINE_INTERFACE (GoaMaps, goa_maps, G_TYPE_OBJECT)

static void
goa_maps_default_init (GoaMapsIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaMapsProxy:
 *
 * The #GoaMapsProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.14.0
 */

/**
 * GoaMapsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMapsProxy.
 *
 * Since: 3.14.0
 */

struct _GoaMapsProxyPrivate
{
  GData *qdata;
};

static void goa_maps_proxy_iface_init (GoaMapsIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMapsProxy, goa_maps_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaMapsProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAPS, goa_maps_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMapsProxy, goa_maps_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAPS, goa_maps_proxy_iface_init))

#endif
static void
goa_maps_proxy_finalize (GObject *object)
{
  GoaMapsProxy *proxy = GOA_MAPS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_maps_proxy_parent_class)->finalize (object);
}

static void
goa_maps_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_maps_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_maps_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_maps_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MAPS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MAPS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_maps_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaMapsProxy *proxy = GOA_MAPS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_maps_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_maps_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_maps_proxy_init (GoaMapsProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_maps_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MAPS_PROXY, GoaMapsProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_maps_interface_info ());
}

static void
goa_maps_proxy_class_init (GoaMapsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_maps_proxy_finalize;
  gobject_class->get_property = goa_maps_proxy_get_property;
  gobject_class->set_property = goa_maps_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_maps_proxy_g_signal;
  proxy_class->g_properties_changed = goa_maps_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMapsProxyPrivate));
#endif
}

static void
goa_maps_proxy_iface_init (GoaMapsIface *iface)
{
}

/**
 * goa_maps_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_maps_proxy_new_finish() to get the result of the operation.
 *
 * See goa_maps_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.14.0
 */
void
goa_maps_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MAPS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Maps", NULL);
}

/**
 * goa_maps_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_maps_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_maps_proxy_new().
 *
 * Returns: (transfer full) (type GoaMapsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14.0
 */
GoaMaps *
goa_maps_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MAPS (ret);
  else
    return NULL;
}

/**
 * goa_maps_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_maps_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMapsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14.0
 */
GoaMaps *
goa_maps_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MAPS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Maps", NULL);
  if (ret != NULL)
    return GOA_MAPS (ret);
  else
    return NULL;
}


/**
 * goa_maps_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_maps_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_maps_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_maps_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.14.0
 */
void
goa_maps_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MAPS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Maps", NULL);
}

/**
 * goa_maps_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_maps_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_maps_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaMapsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14.0
 */
GoaMaps *
goa_maps_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MAPS (ret);
  else
    return NULL;
}

/**
 * goa_maps_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_maps_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_maps_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMapsProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14.0
 */
GoaMaps *
goa_maps_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MAPS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Maps", NULL);
  if (ret != NULL)
    return GOA_MAPS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaMapsSkeleton:
 *
 * The #GoaMapsSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.14.0
 */

/**
 * GoaMapsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMapsSkeleton.
 *
 * Since: 3.14.0
 */

struct _GoaMapsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_maps_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaMapsSkeleton *skeleton = GOA_MAPS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MAPS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MAPS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_maps_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaMapsSkeleton *skeleton = GOA_MAPS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_maps_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_maps_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaMapsSkeleton *skeleton = GOA_MAPS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_maps_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_maps_skeleton_vtable =
{
  _goa_maps_skeleton_handle_method_call,
  _goa_maps_skeleton_handle_get_property,
  _goa_maps_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_maps_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_maps_interface_info ();
}

static GDBusInterfaceVTable *
goa_maps_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_maps_skeleton_vtable;
}

static GVariant *
goa_maps_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMapsSkeleton *skeleton = GOA_MAPS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_maps_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_maps_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_maps_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_maps_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Maps", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_maps_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_maps_skeleton_iface_init (GoaMapsIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMapsSkeleton, goa_maps_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaMapsSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAPS, goa_maps_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMapsSkeleton, goa_maps_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MAPS, goa_maps_skeleton_iface_init))

#endif
static void
goa_maps_skeleton_finalize (GObject *object)
{
  GoaMapsSkeleton *skeleton = GOA_MAPS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_maps_skeleton_parent_class)->finalize (object);
}

static void
goa_maps_skeleton_init (GoaMapsSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_maps_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MAPS_SKELETON, GoaMapsSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_maps_skeleton_class_init (GoaMapsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_maps_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_maps_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_maps_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_maps_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_maps_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMapsSkeletonPrivate));
#endif
}

static void
goa_maps_skeleton_iface_init (GoaMapsIface *iface)
{
}

/**
 * goa_maps_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link>.
 *
 * Returns: (transfer full) (type GoaMapsSkeleton): The skeleton object.
 *
 * Since: 3.14.0
 */
GoaMaps *
goa_maps_skeleton_new (void)
{
  return GOA_MAPS (g_object_new (GOA_TYPE_MAPS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Music
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaMusic
 * @title: GoaMusic
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Music D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Music ---- */

static const _ExtendedGDBusInterfaceInfo _goa_music_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Music",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "music",
};


/**
 * goa_music_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.18.0
 */
GDBusInterfaceInfo *
goa_music_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_music_interface_info.parent_struct;
}

/**
 * goa_music_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaMusic interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.18.0
 */
guint
goa_music_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaMusic:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link>.
 *
 * Since: 3.18.0
 */

/**
 * GoaMusicIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link>.
 *
 * Since: 3.18.0
 */

typedef GoaMusicIface GoaMusicInterface;
G_DEFINE_INTERFACE (GoaMusic, goa_music, G_TYPE_OBJECT)

static void
goa_music_default_init (GoaMusicIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaMusicProxy:
 *
 * The #GoaMusicProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.18.0
 */

/**
 * GoaMusicProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMusicProxy.
 *
 * Since: 3.18.0
 */

struct _GoaMusicProxyPrivate
{
  GData *qdata;
};

static void goa_music_proxy_iface_init (GoaMusicIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMusicProxy, goa_music_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaMusicProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MUSIC, goa_music_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMusicProxy, goa_music_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MUSIC, goa_music_proxy_iface_init))

#endif
static void
goa_music_proxy_finalize (GObject *object)
{
  GoaMusicProxy *proxy = GOA_MUSIC_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_music_proxy_parent_class)->finalize (object);
}

static void
goa_music_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_music_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_music_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_music_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MUSIC);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MUSIC);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_music_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaMusicProxy *proxy = GOA_MUSIC_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_music_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_music_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_music_proxy_init (GoaMusicProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_music_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MUSIC_PROXY, GoaMusicProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_music_interface_info ());
}

static void
goa_music_proxy_class_init (GoaMusicProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_music_proxy_finalize;
  gobject_class->get_property = goa_music_proxy_get_property;
  gobject_class->set_property = goa_music_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_music_proxy_g_signal;
  proxy_class->g_properties_changed = goa_music_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMusicProxyPrivate));
#endif
}

static void
goa_music_proxy_iface_init (GoaMusicIface *iface)
{
}

/**
 * goa_music_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_music_proxy_new_finish() to get the result of the operation.
 *
 * See goa_music_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.18.0
 */
void
goa_music_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MUSIC_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Music", NULL);
}

/**
 * goa_music_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_music_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_music_proxy_new().
 *
 * Returns: (transfer full) (type GoaMusicProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.18.0
 */
GoaMusic *
goa_music_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MUSIC (ret);
  else
    return NULL;
}

/**
 * goa_music_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_music_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMusicProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.18.0
 */
GoaMusic *
goa_music_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MUSIC_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Music", NULL);
  if (ret != NULL)
    return GOA_MUSIC (ret);
  else
    return NULL;
}


/**
 * goa_music_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_music_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_music_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_music_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.18.0
 */
void
goa_music_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MUSIC_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Music", NULL);
}

/**
 * goa_music_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_music_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_music_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaMusicProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.18.0
 */
GoaMusic *
goa_music_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MUSIC (ret);
  else
    return NULL;
}

/**
 * goa_music_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_music_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_music_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMusicProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.18.0
 */
GoaMusic *
goa_music_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MUSIC_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Music", NULL);
  if (ret != NULL)
    return GOA_MUSIC (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaMusicSkeleton:
 *
 * The #GoaMusicSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.18.0
 */

/**
 * GoaMusicSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMusicSkeleton.
 *
 * Since: 3.18.0
 */

struct _GoaMusicSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_music_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaMusicSkeleton *skeleton = GOA_MUSIC_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MUSIC);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MUSIC);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_music_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaMusicSkeleton *skeleton = GOA_MUSIC_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_music_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_music_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaMusicSkeleton *skeleton = GOA_MUSIC_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_music_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_music_skeleton_vtable =
{
  _goa_music_skeleton_handle_method_call,
  _goa_music_skeleton_handle_get_property,
  _goa_music_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_music_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_music_interface_info ();
}

static GDBusInterfaceVTable *
goa_music_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_music_skeleton_vtable;
}

static GVariant *
goa_music_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMusicSkeleton *skeleton = GOA_MUSIC_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_music_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_music_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_music_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_music_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Music", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_music_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_music_skeleton_iface_init (GoaMusicIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMusicSkeleton, goa_music_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaMusicSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MUSIC, goa_music_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMusicSkeleton, goa_music_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MUSIC, goa_music_skeleton_iface_init))

#endif
static void
goa_music_skeleton_finalize (GObject *object)
{
  GoaMusicSkeleton *skeleton = GOA_MUSIC_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_music_skeleton_parent_class)->finalize (object);
}

static void
goa_music_skeleton_init (GoaMusicSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_music_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MUSIC_SKELETON, GoaMusicSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_music_skeleton_class_init (GoaMusicSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_music_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_music_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_music_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_music_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_music_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMusicSkeletonPrivate));
#endif
}

static void
goa_music_skeleton_iface_init (GoaMusicIface *iface)
{
}

/**
 * goa_music_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link>.
 *
 * Returns: (transfer full) (type GoaMusicSkeleton): The skeleton object.
 *
 * Since: 3.18.0
 */
GoaMusic *
goa_music_skeleton_new (void)
{
  return GOA_MUSIC (g_object_new (GOA_TYPE_MUSIC_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Photos
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaPhotos
 * @title: GoaPhotos
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Photos D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Photos ---- */

static const _ExtendedGDBusInterfaceInfo _goa_photos_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Photos",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "photos",
};


/**
 * goa_photos_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.8.0
 */
GDBusInterfaceInfo *
goa_photos_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_photos_interface_info.parent_struct;
}

/**
 * goa_photos_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaPhotos interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.8.0
 */
guint
goa_photos_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaPhotos:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link>.
 *
 * Since: 3.8.0
 */

/**
 * GoaPhotosIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link>.
 *
 * Since: 3.8.0
 */

typedef GoaPhotosIface GoaPhotosInterface;
G_DEFINE_INTERFACE (GoaPhotos, goa_photos, G_TYPE_OBJECT)

static void
goa_photos_default_init (GoaPhotosIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaPhotosProxy:
 *
 * The #GoaPhotosProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.8.0
 */

/**
 * GoaPhotosProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPhotosProxy.
 *
 * Since: 3.8.0
 */

struct _GoaPhotosProxyPrivate
{
  GData *qdata;
};

static void goa_photos_proxy_iface_init (GoaPhotosIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaPhotosProxy, goa_photos_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaPhotosProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PHOTOS, goa_photos_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaPhotosProxy, goa_photos_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PHOTOS, goa_photos_proxy_iface_init))

#endif
static void
goa_photos_proxy_finalize (GObject *object)
{
  GoaPhotosProxy *proxy = GOA_PHOTOS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_photos_proxy_parent_class)->finalize (object);
}

static void
goa_photos_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_photos_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_photos_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_photos_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_PHOTOS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PHOTOS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_photos_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaPhotosProxy *proxy = GOA_PHOTOS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_photos_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_photos_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_photos_proxy_init (GoaPhotosProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_photos_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_PHOTOS_PROXY, GoaPhotosProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_photos_interface_info ());
}

static void
goa_photos_proxy_class_init (GoaPhotosProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_photos_proxy_finalize;
  gobject_class->get_property = goa_photos_proxy_get_property;
  gobject_class->set_property = goa_photos_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_photos_proxy_g_signal;
  proxy_class->g_properties_changed = goa_photos_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaPhotosProxyPrivate));
#endif
}

static void
goa_photos_proxy_iface_init (GoaPhotosIface *iface)
{
}

/**
 * goa_photos_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_photos_proxy_new_finish() to get the result of the operation.
 *
 * See goa_photos_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.8.0
 */
void
goa_photos_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PHOTOS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Photos", NULL);
}

/**
 * goa_photos_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_photos_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_photos_proxy_new().
 *
 * Returns: (transfer full) (type GoaPhotosProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaPhotos *
goa_photos_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PHOTOS (ret);
  else
    return NULL;
}

/**
 * goa_photos_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_photos_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPhotosProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaPhotos *
goa_photos_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PHOTOS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Photos", NULL);
  if (ret != NULL)
    return GOA_PHOTOS (ret);
  else
    return NULL;
}


/**
 * goa_photos_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_photos_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_photos_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_photos_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.8.0
 */
void
goa_photos_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PHOTOS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Photos", NULL);
}

/**
 * goa_photos_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_photos_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_photos_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaPhotosProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaPhotos *
goa_photos_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PHOTOS (ret);
  else
    return NULL;
}

/**
 * goa_photos_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_photos_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_photos_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPhotosProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaPhotos *
goa_photos_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PHOTOS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Photos", NULL);
  if (ret != NULL)
    return GOA_PHOTOS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaPhotosSkeleton:
 *
 * The #GoaPhotosSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.8.0
 */

/**
 * GoaPhotosSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPhotosSkeleton.
 *
 * Since: 3.8.0
 */

struct _GoaPhotosSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_photos_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaPhotosSkeleton *skeleton = GOA_PHOTOS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_PHOTOS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PHOTOS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_photos_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaPhotosSkeleton *skeleton = GOA_PHOTOS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_photos_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_photos_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaPhotosSkeleton *skeleton = GOA_PHOTOS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_photos_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_photos_skeleton_vtable =
{
  _goa_photos_skeleton_handle_method_call,
  _goa_photos_skeleton_handle_get_property,
  _goa_photos_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_photos_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_photos_interface_info ();
}

static GDBusInterfaceVTable *
goa_photos_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_photos_skeleton_vtable;
}

static GVariant *
goa_photos_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaPhotosSkeleton *skeleton = GOA_PHOTOS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_photos_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_photos_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_photos_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_photos_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Photos", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_photos_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_photos_skeleton_iface_init (GoaPhotosIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaPhotosSkeleton, goa_photos_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaPhotosSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PHOTOS, goa_photos_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaPhotosSkeleton, goa_photos_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PHOTOS, goa_photos_skeleton_iface_init))

#endif
static void
goa_photos_skeleton_finalize (GObject *object)
{
  GoaPhotosSkeleton *skeleton = GOA_PHOTOS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_photos_skeleton_parent_class)->finalize (object);
}

static void
goa_photos_skeleton_init (GoaPhotosSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_photos_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_PHOTOS_SKELETON, GoaPhotosSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_photos_skeleton_class_init (GoaPhotosSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_photos_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_photos_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_photos_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_photos_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_photos_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaPhotosSkeletonPrivate));
#endif
}

static void
goa_photos_skeleton_iface_init (GoaPhotosIface *iface)
{
}

/**
 * goa_photos_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link>.
 *
 * Returns: (transfer full) (type GoaPhotosSkeleton): The skeleton object.
 *
 * Since: 3.8.0
 */
GoaPhotos *
goa_photos_skeleton_new (void)
{
  return GOA_PHOTOS (g_object_new (GOA_TYPE_PHOTOS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Files
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaFiles
 * @title: GoaFiles
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Files D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Files ---- */

static const _ExtendedGDBusPropertyInfo _goa_files_property_info_accept_ssl_errors =
{
  {
    -1,
    (gchar *) "AcceptSslErrors",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "accept-ssl-errors",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_files_property_info_uri =
{
  {
    -1,
    (gchar *) "Uri",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "uri",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_files_property_info_pointers[] =
{
  &_goa_files_property_info_accept_ssl_errors.parent_struct,
  &_goa_files_property_info_uri.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_files_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Files",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_files_property_info_pointers,
    NULL
  },
  "files",
};


/**
 * goa_files_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.8.0
 */
GDBusInterfaceInfo *
goa_files_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_files_interface_info.parent_struct;
}

/**
 * goa_files_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaFiles interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.8.0
 */
guint
goa_files_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "accept-ssl-errors");
  g_object_class_override_property (klass, property_id_begin++, "uri");
  return property_id_begin - 1;
}



/**
 * GoaFiles:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link>.
 *
 * Since: 3.8.0
 */

/**
 * GoaFilesIface:
 * @parent_iface: The parent interface.
 * @get_accept_ssl_errors: Getter for the #GoaFiles:accept-ssl-errors property.
 * @get_uri: Getter for the #GoaFiles:uri property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link>.
 *
 * Since: 3.8.0
 */

typedef GoaFilesIface GoaFilesInterface;
G_DEFINE_INTERFACE (GoaFiles, goa_files, G_TYPE_OBJECT)

static void
goa_files_default_init (GoaFilesIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaFiles:accept-ssl-errors:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.AcceptSslErrors">"AcceptSslErrors"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("accept-ssl-errors", "AcceptSslErrors", "AcceptSslErrors", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaFiles:uri:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.Uri">"Uri"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("uri", "Uri", "Uri", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_files_get_accept_ssl_errors: (skip)
 * @object: A #GoaFiles.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_files_get_accept_ssl_errors (GoaFiles *object)
{
  return GOA_FILES_GET_IFACE (object)->get_accept_ssl_errors (object);
}

/**
 * goa_files_set_accept_ssl_errors: (skip)
 * @object: A #GoaFiles.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_files_set_accept_ssl_errors (GoaFiles *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "accept-ssl-errors", value, NULL);
}

/**
 * goa_files_get_uri: (skip)
 * @object: A #GoaFiles.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.Uri">"Uri"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_files_dup_uri() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.8.0
 */
const gchar *
goa_files_get_uri (GoaFiles *object)
{
  return GOA_FILES_GET_IFACE (object)->get_uri (object);
}

/**
 * goa_files_dup_uri: (skip)
 * @object: A #GoaFiles.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.Uri">"Uri"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.8.0
 */
gchar *
goa_files_dup_uri (GoaFiles *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "uri", &value, NULL);
  return value;
}

/**
 * goa_files_set_uri: (skip)
 * @object: A #GoaFiles.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Files.Uri">"Uri"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_files_set_uri (GoaFiles *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "uri", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaFilesProxy:
 *
 * The #GoaFilesProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.8.0
 */

/**
 * GoaFilesProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaFilesProxy.
 *
 * Since: 3.8.0
 */

struct _GoaFilesProxyPrivate
{
  GData *qdata;
};

static void goa_files_proxy_iface_init (GoaFilesIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaFilesProxy, goa_files_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaFilesProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_FILES, goa_files_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaFilesProxy, goa_files_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_FILES, goa_files_proxy_iface_init))

#endif
static void
goa_files_proxy_finalize (GObject *object)
{
  GoaFilesProxy *proxy = GOA_FILES_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_files_proxy_parent_class)->finalize (object);
}

static void
goa_files_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_files_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_files_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Files: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_files_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_files_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Files", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_files_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_files_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_files_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_FILES);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_FILES);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_files_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaFilesProxy *proxy = GOA_FILES_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_files_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_files_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
goa_files_proxy_get_accept_ssl_errors (GoaFiles *object)
{
  GoaFilesProxy *proxy = GOA_FILES_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AcceptSslErrors");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_files_proxy_get_uri (GoaFiles *object)
{
  GoaFilesProxy *proxy = GOA_FILES_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Uri");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_files_proxy_init (GoaFilesProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_files_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_FILES_PROXY, GoaFilesProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_files_interface_info ());
}

static void
goa_files_proxy_class_init (GoaFilesProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_files_proxy_finalize;
  gobject_class->get_property = goa_files_proxy_get_property;
  gobject_class->set_property = goa_files_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_files_proxy_g_signal;
  proxy_class->g_properties_changed = goa_files_proxy_g_properties_changed;

  goa_files_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaFilesProxyPrivate));
#endif
}

static void
goa_files_proxy_iface_init (GoaFilesIface *iface)
{
  iface->get_accept_ssl_errors = goa_files_proxy_get_accept_ssl_errors;
  iface->get_uri = goa_files_proxy_get_uri;
}

/**
 * goa_files_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_files_proxy_new_finish() to get the result of the operation.
 *
 * See goa_files_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.8.0
 */
void
goa_files_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_FILES_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Files", NULL);
}

/**
 * goa_files_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_files_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_files_proxy_new().
 *
 * Returns: (transfer full) (type GoaFilesProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaFiles *
goa_files_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_FILES (ret);
  else
    return NULL;
}

/**
 * goa_files_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_files_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaFilesProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaFiles *
goa_files_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_FILES_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Files", NULL);
  if (ret != NULL)
    return GOA_FILES (ret);
  else
    return NULL;
}


/**
 * goa_files_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_files_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_files_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_files_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.8.0
 */
void
goa_files_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_FILES_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Files", NULL);
}

/**
 * goa_files_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_files_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_files_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaFilesProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaFiles *
goa_files_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_FILES (ret);
  else
    return NULL;
}

/**
 * goa_files_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_files_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_files_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaFilesProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.8.0
 */
GoaFiles *
goa_files_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_FILES_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Files", NULL);
  if (ret != NULL)
    return GOA_FILES (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaFilesSkeleton:
 *
 * The #GoaFilesSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.8.0
 */

/**
 * GoaFilesSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaFilesSkeleton.
 *
 * Since: 3.8.0
 */

struct _GoaFilesSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_files_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_FILES);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_FILES);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_files_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_files_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_files_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_files_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_files_skeleton_vtable =
{
  _goa_files_skeleton_handle_method_call,
  _goa_files_skeleton_handle_get_property,
  _goa_files_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_files_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_files_interface_info ();
}

static GDBusInterfaceVTable *
goa_files_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_files_skeleton_vtable;
}

static GVariant *
goa_files_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_files_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_files_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_files_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_files_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Files", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_files_emit_changed (gpointer user_data);

static void
goa_files_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_files_emit_changed (skeleton);
}

static void goa_files_skeleton_iface_init (GoaFilesIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaFilesSkeleton, goa_files_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaFilesSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_FILES, goa_files_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaFilesSkeleton, goa_files_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_FILES, goa_files_skeleton_iface_init))

#endif
static void
goa_files_skeleton_finalize (GObject *object)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_files_skeleton_parent_class)->finalize (object);
}

static void
goa_files_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_files_emit_changed (gpointer user_data)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Files",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_files_schedule_emit_changed (GoaFilesSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_files_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_files_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_files_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_files_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_files_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_files_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_files_skeleton_init (GoaFilesSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_files_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_FILES_SKELETON, GoaFilesSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gboolean 
goa_files_skeleton_get_accept_ssl_errors (GoaFiles *object)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_files_skeleton_get_uri (GoaFiles *object)
{
  GoaFilesSkeleton *skeleton = GOA_FILES_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_files_skeleton_class_init (GoaFilesSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_files_skeleton_finalize;
  gobject_class->get_property = goa_files_skeleton_get_property;
  gobject_class->set_property = goa_files_skeleton_set_property;
  gobject_class->notify       = goa_files_skeleton_notify;


  goa_files_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_files_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_files_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_files_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_files_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaFilesSkeletonPrivate));
#endif
}

static void
goa_files_skeleton_iface_init (GoaFilesIface *iface)
{
  iface->get_accept_ssl_errors = goa_files_skeleton_get_accept_ssl_errors;
  iface->get_uri = goa_files_skeleton_get_uri;
}

/**
 * goa_files_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link>.
 *
 * Returns: (transfer full) (type GoaFilesSkeleton): The skeleton object.
 *
 * Since: 3.8.0
 */
GoaFiles *
goa_files_skeleton_new (void)
{
  return GOA_FILES (g_object_new (GOA_TYPE_FILES_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Exchange
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaExchange
 * @title: GoaExchange
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Exchange D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Exchange ---- */

static const _ExtendedGDBusPropertyInfo _goa_exchange_property_info_accept_ssl_errors =
{
  {
    -1,
    (gchar *) "AcceptSslErrors",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "accept-ssl-errors",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_exchange_property_info_host =
{
  {
    -1,
    (gchar *) "Host",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "host",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_exchange_property_info_pointers[] =
{
  &_goa_exchange_property_info_accept_ssl_errors.parent_struct,
  &_goa_exchange_property_info_host.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_exchange_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Exchange",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_exchange_property_info_pointers,
    NULL
  },
  "exchange",
};


/**
 * goa_exchange_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.6.0
 */
GDBusInterfaceInfo *
goa_exchange_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct;
}

/**
 * goa_exchange_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaExchange interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.6.0
 */
guint
goa_exchange_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "accept-ssl-errors");
  g_object_class_override_property (klass, property_id_begin++, "host");
  return property_id_begin - 1;
}



/**
 * GoaExchange:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>.
 *
 * Since: 3.6.0
 */

/**
 * GoaExchangeIface:
 * @parent_iface: The parent interface.
 * @get_host: Getter for the #GoaExchange:host property.
 * @get_accept_ssl_errors: Getter for the #GoaExchange:accept-ssl-errors property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>.
 *
 * Since: 3.6.0
 */

typedef GoaExchangeIface GoaExchangeInterface;
G_DEFINE_INTERFACE (GoaExchange, goa_exchange, G_TYPE_OBJECT)

static void
goa_exchange_default_init (GoaExchangeIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaExchange:accept-ssl-errors:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.AcceptSslErrors">"AcceptSslErrors"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("accept-ssl-errors", "AcceptSslErrors", "AcceptSslErrors", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaExchange:host:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("host", "Host", "Host", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_exchange_get_accept_ssl_errors: (skip)
 * @object: A #GoaExchange.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.8.0
 */
gboolean 
goa_exchange_get_accept_ssl_errors (GoaExchange *object)
{
  return GOA_EXCHANGE_GET_IFACE (object)->get_accept_ssl_errors (object);
}

/**
 * goa_exchange_set_accept_ssl_errors: (skip)
 * @object: A #GoaExchange.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.AcceptSslErrors">"AcceptSslErrors"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.8.0
 */
void
goa_exchange_set_accept_ssl_errors (GoaExchange *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "accept-ssl-errors", value, NULL);
}

/**
 * goa_exchange_get_host: (skip)
 * @object: A #GoaExchange.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_exchange_dup_host() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.6.0
 */
const gchar *
goa_exchange_get_host (GoaExchange *object)
{
  return GOA_EXCHANGE_GET_IFACE (object)->get_host (object);
}

/**
 * goa_exchange_dup_host: (skip)
 * @object: A #GoaExchange.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.6.0
 */
gchar *
goa_exchange_dup_host (GoaExchange *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "host", &value, NULL);
  return value;
}

/**
 * goa_exchange_set_host: (skip)
 * @object: A #GoaExchange.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Exchange.Host">"Host"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.6.0
 */
void
goa_exchange_set_host (GoaExchange *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "host", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaExchangeProxy:
 *
 * The #GoaExchangeProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaExchangeProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaExchangeProxy.
 *
 * Since: 3.6.0
 */

struct _GoaExchangeProxyPrivate
{
  GData *qdata;
};

static void goa_exchange_proxy_iface_init (GoaExchangeIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaExchangeProxy, goa_exchange_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaExchangeProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_EXCHANGE, goa_exchange_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaExchangeProxy, goa_exchange_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_EXCHANGE, goa_exchange_proxy_iface_init))

#endif
static void
goa_exchange_proxy_finalize (GObject *object)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_exchange_proxy_parent_class)->finalize (object);
}

static void
goa_exchange_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_exchange_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_exchange_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Exchange: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_exchange_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_exchange_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Exchange", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_exchange_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_exchange_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_EXCHANGE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_EXCHANGE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_exchange_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
goa_exchange_proxy_get_accept_ssl_errors (GoaExchange *object)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AcceptSslErrors");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_exchange_proxy_get_host (GoaExchange *object)
{
  GoaExchangeProxy *proxy = GOA_EXCHANGE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Host");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_exchange_proxy_init (GoaExchangeProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_exchange_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_EXCHANGE_PROXY, GoaExchangeProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_exchange_interface_info ());
}

static void
goa_exchange_proxy_class_init (GoaExchangeProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_exchange_proxy_finalize;
  gobject_class->get_property = goa_exchange_proxy_get_property;
  gobject_class->set_property = goa_exchange_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_exchange_proxy_g_signal;
  proxy_class->g_properties_changed = goa_exchange_proxy_g_properties_changed;

  goa_exchange_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaExchangeProxyPrivate));
#endif
}

static void
goa_exchange_proxy_iface_init (GoaExchangeIface *iface)
{
  iface->get_accept_ssl_errors = goa_exchange_proxy_get_accept_ssl_errors;
  iface->get_host = goa_exchange_proxy_get_host;
}

/**
 * goa_exchange_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_exchange_proxy_new_finish() to get the result of the operation.
 *
 * See goa_exchange_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_exchange_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_EXCHANGE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
}

/**
 * goa_exchange_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_exchange_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_exchange_proxy_new().
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}

/**
 * goa_exchange_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_exchange_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_EXCHANGE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}


/**
 * goa_exchange_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_exchange_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_exchange_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_exchange_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_exchange_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_EXCHANGE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
}

/**
 * goa_exchange_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_exchange_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_exchange_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}

/**
 * goa_exchange_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_exchange_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_exchange_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaExchangeProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_EXCHANGE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Exchange", NULL);
  if (ret != NULL)
    return GOA_EXCHANGE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaExchangeSkeleton:
 *
 * The #GoaExchangeSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaExchangeSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaExchangeSkeleton.
 *
 * Since: 3.6.0
 */

struct _GoaExchangeSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_exchange_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_EXCHANGE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_EXCHANGE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_exchange_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_exchange_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_exchange_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_exchange_skeleton_vtable =
{
  _goa_exchange_skeleton_handle_method_call,
  _goa_exchange_skeleton_handle_get_property,
  _goa_exchange_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_exchange_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_exchange_interface_info ();
}

static GDBusInterfaceVTable *
goa_exchange_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_exchange_skeleton_vtable;
}

static GVariant *
goa_exchange_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_exchange_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_exchange_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_exchange_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_exchange_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Exchange", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_exchange_emit_changed (gpointer user_data);

static void
goa_exchange_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_exchange_emit_changed (skeleton);
}

static void goa_exchange_skeleton_iface_init (GoaExchangeIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaExchangeSkeleton, goa_exchange_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaExchangeSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_EXCHANGE, goa_exchange_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaExchangeSkeleton, goa_exchange_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_EXCHANGE, goa_exchange_skeleton_iface_init))

#endif
static void
goa_exchange_skeleton_finalize (GObject *object)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_exchange_skeleton_parent_class)->finalize (object);
}

static void
goa_exchange_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_exchange_emit_changed (gpointer user_data)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Exchange",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_exchange_schedule_emit_changed (GoaExchangeSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_exchange_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_exchange_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_exchange_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_exchange_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_exchange_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_exchange_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_exchange_skeleton_init (GoaExchangeSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_exchange_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_EXCHANGE_SKELETON, GoaExchangeSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gboolean 
goa_exchange_skeleton_get_accept_ssl_errors (GoaExchange *object)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_exchange_skeleton_get_host (GoaExchange *object)
{
  GoaExchangeSkeleton *skeleton = GOA_EXCHANGE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_exchange_skeleton_class_init (GoaExchangeSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_exchange_skeleton_finalize;
  gobject_class->get_property = goa_exchange_skeleton_get_property;
  gobject_class->set_property = goa_exchange_skeleton_set_property;
  gobject_class->notify       = goa_exchange_skeleton_notify;


  goa_exchange_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_exchange_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_exchange_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_exchange_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_exchange_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaExchangeSkeletonPrivate));
#endif
}

static void
goa_exchange_skeleton_iface_init (GoaExchangeIface *iface)
{
  iface->get_accept_ssl_errors = goa_exchange_skeleton_get_accept_ssl_errors;
  iface->get_host = goa_exchange_skeleton_get_host;
}

/**
 * goa_exchange_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>.
 *
 * Returns: (transfer full) (type GoaExchangeSkeleton): The skeleton object.
 *
 * Since: 3.6.0
 */
GoaExchange *
goa_exchange_skeleton_new (void)
{
  return GOA_EXCHANGE (g_object_new (GOA_TYPE_EXCHANGE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.MediaServer
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaMediaServer
 * @title: GoaMediaServer
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.MediaServer D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.MediaServer ---- */

static const _ExtendedGDBusPropertyInfo _goa_media_server_property_info_dlna_supported =
{
  {
    -1,
    (gchar *) "DlnaSupported",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "dlna-supported",
  FALSE,
  TRUE
};

static const _ExtendedGDBusPropertyInfo _goa_media_server_property_info_udn =
{
  {
    -1,
    (gchar *) "Udn",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "udn",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_media_server_property_info_pointers[] =
{
  &_goa_media_server_property_info_dlna_supported.parent_struct,
  &_goa_media_server_property_info_udn.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_media_server_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.MediaServer",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_goa_media_server_property_info_pointers,
    NULL
  },
  "media-server",
};


/**
 * goa_media_server_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.14
 */
GDBusInterfaceInfo *
goa_media_server_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_media_server_interface_info.parent_struct;
}

/**
 * goa_media_server_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaMediaServer interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.14
 */
guint
goa_media_server_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "dlna-supported");
  g_object_class_override_property (klass, property_id_begin++, "udn");
  return property_id_begin - 1;
}



/**
 * GoaMediaServer:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link>.
 *
 * Since: 3.14
 */

/**
 * GoaMediaServerIface:
 * @parent_iface: The parent interface.
 * @get_dlna_supported: Getter for the #GoaMediaServer:dlna-supported property.
 * @get_udn: Getter for the #GoaMediaServer:udn property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link>.
 *
 * Since: 3.14
 */

typedef GoaMediaServerIface GoaMediaServerInterface;
G_DEFINE_INTERFACE (GoaMediaServer, goa_media_server, G_TYPE_OBJECT)

static void
goa_media_server_default_init (GoaMediaServerIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * GoaMediaServer:dlna-supported:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.DlnaSupported">"DlnaSupported"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.14
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("dlna-supported", "DlnaSupported", "DlnaSupported", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * GoaMediaServer:udn:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.Udn">"Udn"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.14
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("udn", "Udn", "Udn", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_media_server_get_dlna_supported: (skip)
 * @object: A #GoaMediaServer.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.DlnaSupported">"DlnaSupported"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Since: 3.14
 */
gboolean 
goa_media_server_get_dlna_supported (GoaMediaServer *object)
{
  return GOA_MEDIA_SERVER_GET_IFACE (object)->get_dlna_supported (object);
}

/**
 * goa_media_server_set_dlna_supported: (skip)
 * @object: A #GoaMediaServer.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.DlnaSupported">"DlnaSupported"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.14
 */
void
goa_media_server_set_dlna_supported (GoaMediaServer *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "dlna-supported", value, NULL);
}

/**
 * goa_media_server_get_udn: (skip)
 * @object: A #GoaMediaServer.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.Udn">"Udn"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_media_server_dup_udn() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.14
 */
const gchar *
goa_media_server_get_udn (GoaMediaServer *object)
{
  return GOA_MEDIA_SERVER_GET_IFACE (object)->get_udn (object);
}

/**
 * goa_media_server_dup_udn: (skip)
 * @object: A #GoaMediaServer.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.Udn">"Udn"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 *
 * Since: 3.14
 */
gchar *
goa_media_server_dup_udn (GoaMediaServer *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "udn", &value, NULL);
  return value;
}

/**
 * goa_media_server_set_udn: (skip)
 * @object: A #GoaMediaServer.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-MediaServer.Udn">"Udn"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.14
 */
void
goa_media_server_set_udn (GoaMediaServer *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "udn", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * GoaMediaServerProxy:
 *
 * The #GoaMediaServerProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.14
 */

/**
 * GoaMediaServerProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMediaServerProxy.
 *
 * Since: 3.14
 */

struct _GoaMediaServerProxyPrivate
{
  GData *qdata;
};

static void goa_media_server_proxy_iface_init (GoaMediaServerIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMediaServerProxy, goa_media_server_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaMediaServerProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MEDIA_SERVER, goa_media_server_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMediaServerProxy, goa_media_server_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MEDIA_SERVER, goa_media_server_proxy_iface_init))

#endif
static void
goa_media_server_proxy_finalize (GObject *object)
{
  GoaMediaServerProxy *proxy = GOA_MEDIA_SERVER_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_media_server_proxy_parent_class)->finalize (object);
}

static void
goa_media_server_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_media_server_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_media_server_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.MediaServer: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_media_server_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_media_server_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.MediaServer", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_media_server_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_media_server_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_media_server_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_MEDIA_SERVER);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MEDIA_SERVER);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_media_server_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaMediaServerProxy *proxy = GOA_MEDIA_SERVER_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_media_server_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_media_server_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
goa_media_server_proxy_get_dlna_supported (GoaMediaServer *object)
{
  GoaMediaServerProxy *proxy = GOA_MEDIA_SERVER_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DlnaSupported");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
goa_media_server_proxy_get_udn (GoaMediaServer *object)
{
  GoaMediaServerProxy *proxy = GOA_MEDIA_SERVER_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Udn");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
goa_media_server_proxy_init (GoaMediaServerProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_media_server_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_MEDIA_SERVER_PROXY, GoaMediaServerProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_media_server_interface_info ());
}

static void
goa_media_server_proxy_class_init (GoaMediaServerProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_media_server_proxy_finalize;
  gobject_class->get_property = goa_media_server_proxy_get_property;
  gobject_class->set_property = goa_media_server_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_media_server_proxy_g_signal;
  proxy_class->g_properties_changed = goa_media_server_proxy_g_properties_changed;

  goa_media_server_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMediaServerProxyPrivate));
#endif
}

static void
goa_media_server_proxy_iface_init (GoaMediaServerIface *iface)
{
  iface->get_dlna_supported = goa_media_server_proxy_get_dlna_supported;
  iface->get_udn = goa_media_server_proxy_get_udn;
}

/**
 * goa_media_server_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_media_server_proxy_new_finish() to get the result of the operation.
 *
 * See goa_media_server_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.14
 */
void
goa_media_server_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MEDIA_SERVER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.MediaServer", NULL);
}

/**
 * goa_media_server_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_media_server_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_media_server_proxy_new().
 *
 * Returns: (transfer full) (type GoaMediaServerProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14
 */
GoaMediaServer *
goa_media_server_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MEDIA_SERVER (ret);
  else
    return NULL;
}

/**
 * goa_media_server_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_media_server_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMediaServerProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14
 */
GoaMediaServer *
goa_media_server_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MEDIA_SERVER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.MediaServer", NULL);
  if (ret != NULL)
    return GOA_MEDIA_SERVER (ret);
  else
    return NULL;
}


/**
 * goa_media_server_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_media_server_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_media_server_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_media_server_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.14
 */
void
goa_media_server_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_MEDIA_SERVER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.MediaServer", NULL);
}

/**
 * goa_media_server_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_media_server_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_media_server_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaMediaServerProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14
 */
GoaMediaServer *
goa_media_server_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_MEDIA_SERVER (ret);
  else
    return NULL;
}

/**
 * goa_media_server_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_media_server_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_media_server_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaMediaServerProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.14
 */
GoaMediaServer *
goa_media_server_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_MEDIA_SERVER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.MediaServer", NULL);
  if (ret != NULL)
    return GOA_MEDIA_SERVER (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaMediaServerSkeleton:
 *
 * The #GoaMediaServerSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.14
 */

/**
 * GoaMediaServerSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaMediaServerSkeleton.
 *
 * Since: 3.14
 */

struct _GoaMediaServerSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_media_server_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_MEDIA_SERVER);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_MEDIA_SERVER);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_media_server_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_media_server_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_media_server_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_media_server_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_media_server_skeleton_vtable =
{
  _goa_media_server_skeleton_handle_method_call,
  _goa_media_server_skeleton_handle_get_property,
  _goa_media_server_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_media_server_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_media_server_interface_info ();
}

static GDBusInterfaceVTable *
goa_media_server_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_media_server_skeleton_vtable;
}

static GVariant *
goa_media_server_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_media_server_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_media_server_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_media_server_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_media_server_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.MediaServer", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_media_server_emit_changed (gpointer user_data);

static void
goa_media_server_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_media_server_emit_changed (skeleton);
}

static void goa_media_server_skeleton_iface_init (GoaMediaServerIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaMediaServerSkeleton, goa_media_server_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaMediaServerSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MEDIA_SERVER, goa_media_server_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaMediaServerSkeleton, goa_media_server_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_MEDIA_SERVER, goa_media_server_skeleton_iface_init))

#endif
static void
goa_media_server_skeleton_finalize (GObject *object)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_media_server_skeleton_parent_class)->finalize (object);
}

static void
goa_media_server_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_media_server_emit_changed (gpointer user_data)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.MediaServer",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_media_server_schedule_emit_changed (GoaMediaServerSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_media_server_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_media_server_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_media_server_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_media_server_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_media_server_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_media_server_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_media_server_skeleton_init (GoaMediaServerSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_media_server_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_MEDIA_SERVER_SKELETON, GoaMediaServerSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gboolean 
goa_media_server_skeleton_get_dlna_supported (GoaMediaServer *object)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
goa_media_server_skeleton_get_udn (GoaMediaServer *object)
{
  GoaMediaServerSkeleton *skeleton = GOA_MEDIA_SERVER_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_media_server_skeleton_class_init (GoaMediaServerSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_media_server_skeleton_finalize;
  gobject_class->get_property = goa_media_server_skeleton_get_property;
  gobject_class->set_property = goa_media_server_skeleton_set_property;
  gobject_class->notify       = goa_media_server_skeleton_notify;


  goa_media_server_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_media_server_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_media_server_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_media_server_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_media_server_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaMediaServerSkeletonPrivate));
#endif
}

static void
goa_media_server_skeleton_iface_init (GoaMediaServerIface *iface)
{
  iface->get_dlna_supported = goa_media_server_skeleton_get_dlna_supported;
  iface->get_udn = goa_media_server_skeleton_get_udn;
}

/**
 * goa_media_server_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link>.
 *
 * Returns: (transfer full) (type GoaMediaServerSkeleton): The skeleton object.
 *
 * Since: 3.14
 */
GoaMediaServer *
goa_media_server_skeleton_new (void)
{
  return GOA_MEDIA_SERVER (g_object_new (GOA_TYPE_MEDIA_SERVER_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Ticketing
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaTicketing
 * @title: GoaTicketing
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Ticketing D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Ticketing ---- */

static const _ExtendedGDBusMethodInfo _goa_ticketing_method_info_get_ticket =
{
  {
    -1,
    (gchar *) "GetTicket",
    NULL,
    NULL,
    NULL
  },
  "handle-get-ticket",
  FALSE
};

static const GDBusMethodInfo * const _goa_ticketing_method_info_pointers[] =
{
  &_goa_ticketing_method_info_get_ticket.parent_struct,
  NULL
};

static const _ExtendedGDBusPropertyInfo _goa_ticketing_property_info_details =
{
  {
    -1,
    (gchar *) "Details",
    (gchar *) "a{ss}",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "details",
  FALSE,
  TRUE
};

static const GDBusPropertyInfo * const _goa_ticketing_property_info_pointers[] =
{
  &_goa_ticketing_property_info_details.parent_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_ticketing_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Ticketing",
    (GDBusMethodInfo **) &_goa_ticketing_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_goa_ticketing_property_info_pointers,
    NULL
  },
  "ticketing",
};


/**
 * goa_ticketing_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.6.0
 */
GDBusInterfaceInfo *
goa_ticketing_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct;
}

/**
 * goa_ticketing_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaTicketing interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.6.0
 */
guint
goa_ticketing_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "details");
  return property_id_begin - 1;
}



/**
 * GoaTicketing:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>.
 *
 * Since: 3.6.0
 */

/**
 * GoaTicketingIface:
 * @parent_iface: The parent interface.
 * @handle_get_ticket: Handler for the #GoaTicketing::handle-get-ticket signal.
 * @get_details: Getter for the #GoaTicketing:details property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>.
 *
 * Since: 3.6.0
 */

typedef GoaTicketingIface GoaTicketingInterface;
G_DEFINE_INTERFACE (GoaTicketing, goa_ticketing, G_TYPE_OBJECT)

static void
goa_ticketing_default_init (GoaTicketingIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * GoaTicketing::handle-get-ticket:
   * @object: A #GoaTicketing.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call goa_ticketing_complete_get_ticket() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 3.6.0
   */
  g_signal_new ("handle-get-ticket",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (GoaTicketingIface, handle_get_ticket),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * GoaTicketing:details:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-gnome-OnlineAccounts-Ticketing.Details">"Details"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   *
   * Since: 3.18
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("details", "Details", "Details", G_VARIANT_TYPE ("a{ss}"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * goa_ticketing_get_details: (skip)
 * @object: A #GoaTicketing.
 *
 * Gets the value of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Ticketing.Details">"Details"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use goa_ticketing_dup_details() if on another thread.
 *
 * Returns: (transfer none) (nullable): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 *
 * Since: 3.18
 */
GVariant *
goa_ticketing_get_details (GoaTicketing *object)
{
  return GOA_TICKETING_GET_IFACE (object)->get_details (object);
}

/**
 * goa_ticketing_dup_details: (skip)
 * @object: A #GoaTicketing.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Ticketing.Details">"Details"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full) (nullable): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 *
 * Since: 3.18
 */
GVariant *
goa_ticketing_dup_details (GoaTicketing *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "details", &value, NULL);
  return value;
}

/**
 * goa_ticketing_set_details: (skip)
 * @object: A #GoaTicketing.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-gnome-OnlineAccounts-Ticketing.Details">"Details"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 *
 * Since: 3.18
 */
void
goa_ticketing_set_details (GoaTicketing *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "details", value, NULL);
}

/**
 * goa_ticketing_call_get_ticket:
 * @proxy: A #GoaTicketingProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_ticketing_call_get_ticket_finish() to get the result of the operation.
 *
 * See goa_ticketing_call_get_ticket_sync() for the synchronous, blocking version of this method.
 *
 * Since: 3.6.0
 */
void
goa_ticketing_call_get_ticket (
    GoaTicketing *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetTicket",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * goa_ticketing_call_get_ticket_finish:
 * @proxy: A #GoaTicketingProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_ticketing_call_get_ticket().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with goa_ticketing_call_get_ticket().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 *
 * Since: 3.6.0
 */
gboolean
goa_ticketing_call_get_ticket_finish (
    GoaTicketing *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_ticketing_call_get_ticket_sync:
 * @proxy: A #GoaTicketingProxy.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See goa_ticketing_call_get_ticket() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 *
 * Since: 3.6.0
 */
gboolean
goa_ticketing_call_get_ticket_sync (
    GoaTicketing *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetTicket",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * goa_ticketing_complete_get_ticket:
 * @object: A #GoaTicketing.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-gnome-OnlineAccounts-Ticketing.GetTicket">GetTicket()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 3.6.0
 */
void
goa_ticketing_complete_get_ticket (
    GoaTicketing *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * GoaTicketingProxy:
 *
 * The #GoaTicketingProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaTicketingProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaTicketingProxy.
 *
 * Since: 3.6.0
 */

struct _GoaTicketingProxyPrivate
{
  GData *qdata;
};

static void goa_ticketing_proxy_iface_init (GoaTicketingIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaTicketingProxy, goa_ticketing_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaTicketingProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TICKETING, goa_ticketing_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaTicketingProxy, goa_ticketing_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TICKETING, goa_ticketing_proxy_iface_init))

#endif
static void
goa_ticketing_proxy_finalize (GObject *object)
{
  GoaTicketingProxy *proxy = GOA_TICKETING_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_ticketing_proxy_parent_class)->finalize (object);
}

static void
goa_ticketing_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_ticketing_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
goa_ticketing_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.gnome.OnlineAccounts.Ticketing: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
goa_ticketing_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_ticketing_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.gnome.OnlineAccounts.Ticketing", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) goa_ticketing_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
goa_ticketing_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_TICKETING);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_TICKETING);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_ticketing_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaTicketingProxy *proxy = GOA_TICKETING_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
goa_ticketing_proxy_get_details (GoaTicketing *object)
{
  GoaTicketingProxy *proxy = GOA_TICKETING_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Details");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static void
goa_ticketing_proxy_init (GoaTicketingProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_ticketing_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_TICKETING_PROXY, GoaTicketingProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_ticketing_interface_info ());
}

static void
goa_ticketing_proxy_class_init (GoaTicketingProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_ticketing_proxy_finalize;
  gobject_class->get_property = goa_ticketing_proxy_get_property;
  gobject_class->set_property = goa_ticketing_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_ticketing_proxy_g_signal;
  proxy_class->g_properties_changed = goa_ticketing_proxy_g_properties_changed;

  goa_ticketing_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaTicketingProxyPrivate));
#endif
}

static void
goa_ticketing_proxy_iface_init (GoaTicketingIface *iface)
{
  iface->get_details = goa_ticketing_proxy_get_details;
}

/**
 * goa_ticketing_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_ticketing_proxy_new_finish() to get the result of the operation.
 *
 * See goa_ticketing_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_ticketing_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_TICKETING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
}

/**
 * goa_ticketing_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_ticketing_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_ticketing_proxy_new().
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaTicketing *
goa_ticketing_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}

/**
 * goa_ticketing_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_ticketing_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaTicketing *
goa_ticketing_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_TICKETING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}


/**
 * goa_ticketing_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_ticketing_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_ticketing_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_ticketing_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.6.0
 */
void
goa_ticketing_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_TICKETING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
}

/**
 * goa_ticketing_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_ticketing_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_ticketing_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaTicketing *
goa_ticketing_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}

/**
 * goa_ticketing_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_ticketing_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_ticketing_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaTicketingProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.6.0
 */
GoaTicketing *
goa_ticketing_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_TICKETING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Ticketing", NULL);
  if (ret != NULL)
    return GOA_TICKETING (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaTicketingSkeleton:
 *
 * The #GoaTicketingSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.6.0
 */

/**
 * GoaTicketingSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaTicketingSkeleton.
 *
 * Since: 3.6.0
 */

struct _GoaTicketingSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_ticketing_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_TICKETING);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_TICKETING);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_ticketing_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_ticketing_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_ticketing_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_ticketing_skeleton_vtable =
{
  _goa_ticketing_skeleton_handle_method_call,
  _goa_ticketing_skeleton_handle_get_property,
  _goa_ticketing_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_ticketing_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_ticketing_interface_info ();
}

static GDBusInterfaceVTable *
goa_ticketing_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_ticketing_skeleton_vtable;
}

static GVariant *
goa_ticketing_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_ticketing_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_ticketing_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_ticketing_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_ticketing_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Ticketing", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _goa_ticketing_emit_changed (gpointer user_data);

static void
goa_ticketing_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _goa_ticketing_emit_changed (skeleton);
}

static void goa_ticketing_skeleton_iface_init (GoaTicketingIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaTicketingSkeleton, goa_ticketing_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaTicketingSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TICKETING, goa_ticketing_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaTicketingSkeleton, goa_ticketing_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TICKETING, goa_ticketing_skeleton_iface_init))

#endif
static void
goa_ticketing_skeleton_finalize (GObject *object)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_ticketing_skeleton_parent_class)->finalize (object);
}

static void
goa_ticketing_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_goa_ticketing_emit_changed (gpointer user_data)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.gnome.OnlineAccounts.Ticketing",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_goa_ticketing_schedule_emit_changed (GoaTicketingSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
goa_ticketing_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _goa_ticketing_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _goa_ticketing_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
goa_ticketing_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = (const _ExtendedGDBusPropertyInfo *) _goa_ticketing_property_info_pointers[prop_id - 1];
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&
          info->emits_changed_signal)
        _goa_ticketing_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
goa_ticketing_skeleton_init (GoaTicketingSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_ticketing_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_TICKETING_SKELETON, GoaTicketingSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
}

static GVariant *
goa_ticketing_skeleton_get_details (GoaTicketing *object)
{
  GoaTicketingSkeleton *skeleton = GOA_TICKETING_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
goa_ticketing_skeleton_class_init (GoaTicketingSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_ticketing_skeleton_finalize;
  gobject_class->get_property = goa_ticketing_skeleton_get_property;
  gobject_class->set_property = goa_ticketing_skeleton_set_property;
  gobject_class->notify       = goa_ticketing_skeleton_notify;


  goa_ticketing_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_ticketing_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_ticketing_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_ticketing_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_ticketing_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaTicketingSkeletonPrivate));
#endif
}

static void
goa_ticketing_skeleton_iface_init (GoaTicketingIface *iface)
{
  iface->get_details = goa_ticketing_skeleton_get_details;
}

/**
 * goa_ticketing_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>.
 *
 * Returns: (transfer full) (type GoaTicketingSkeleton): The skeleton object.
 *
 * Since: 3.6.0
 */
GoaTicketing *
goa_ticketing_skeleton_new (void)
{
  return GOA_TICKETING (g_object_new (GOA_TYPE_TICKETING_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Todo
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaTodo
 * @title: GoaTodo
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Todo D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Todo ---- */

static const GDBusAnnotationInfo _goa_todo_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _goa_todo_annotation_info_pointers[] =
{
  &_goa_todo_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_todo_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Todo",
    NULL,
    NULL,
    NULL,
    (GDBusAnnotationInfo **) &_goa_todo_annotation_info_pointers
  },
  "todo",
};


/**
 * goa_todo_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GDBusInterfaceInfo *
goa_todo_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_todo_interface_info.parent_struct;
}

/**
 * goa_todo_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaTodo interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
guint
goa_todo_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaTodo:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link>.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaTodoIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link>.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

typedef GoaTodoIface GoaTodoInterface;
G_DEFINE_INTERFACE (GoaTodo, goa_todo, G_TYPE_OBJECT)

static void
goa_todo_default_init (GoaTodoIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaTodoProxy:
 *
 * The #GoaTodoProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaTodoProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaTodoProxy.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _GoaTodoProxyPrivate
{
  GData *qdata;
};

static void goa_todo_proxy_iface_init (GoaTodoIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaTodoProxy, goa_todo_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaTodoProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TODO, goa_todo_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaTodoProxy, goa_todo_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TODO, goa_todo_proxy_iface_init))

#endif
static void
goa_todo_proxy_finalize (GObject *object)
{
  GoaTodoProxy *proxy = GOA_TODO_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_todo_proxy_parent_class)->finalize (object);
}

static void
goa_todo_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_todo_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_todo_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_todo_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_TODO);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_TODO);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_todo_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaTodoProxy *proxy = GOA_TODO_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_todo_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_todo_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_todo_proxy_init (GoaTodoProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_todo_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_TODO_PROXY, GoaTodoProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_todo_interface_info ());
}

static void
goa_todo_proxy_class_init (GoaTodoProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_todo_proxy_finalize;
  gobject_class->get_property = goa_todo_proxy_get_property;
  gobject_class->set_property = goa_todo_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_todo_proxy_g_signal;
  proxy_class->g_properties_changed = goa_todo_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaTodoProxyPrivate));
#endif
}

static void
goa_todo_proxy_iface_init (GoaTodoIface *iface)
{
}

/**
 * goa_todo_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_todo_proxy_new_finish() to get the result of the operation.
 *
 * See goa_todo_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
goa_todo_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_TODO_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Todo", NULL);
}

/**
 * goa_todo_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_todo_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_todo_proxy_new().
 *
 * Returns: (transfer full) (type GoaTodoProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *
goa_todo_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_TODO (ret);
  else
    return NULL;
}

/**
 * goa_todo_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_todo_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaTodoProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *
goa_todo_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_TODO_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Todo", NULL);
  if (ret != NULL)
    return GOA_TODO (ret);
  else
    return NULL;
}


/**
 * goa_todo_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_todo_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_todo_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_todo_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
goa_todo_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_TODO_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Todo", NULL);
}

/**
 * goa_todo_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_todo_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_todo_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaTodoProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *
goa_todo_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_TODO (ret);
  else
    return NULL;
}

/**
 * goa_todo_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_todo_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_todo_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaTodoProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *
goa_todo_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_TODO_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Todo", NULL);
  if (ret != NULL)
    return GOA_TODO (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaTodoSkeleton:
 *
 * The #GoaTodoSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaTodoSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaTodoSkeleton.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _GoaTodoSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_todo_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaTodoSkeleton *skeleton = GOA_TODO_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_TODO);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_TODO);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_todo_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaTodoSkeleton *skeleton = GOA_TODO_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_todo_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_todo_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaTodoSkeleton *skeleton = GOA_TODO_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_todo_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_todo_skeleton_vtable =
{
  _goa_todo_skeleton_handle_method_call,
  _goa_todo_skeleton_handle_get_property,
  _goa_todo_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_todo_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_todo_interface_info ();
}

static GDBusInterfaceVTable *
goa_todo_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_todo_skeleton_vtable;
}

static GVariant *
goa_todo_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaTodoSkeleton *skeleton = GOA_TODO_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_todo_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_todo_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_todo_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_todo_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Todo", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_todo_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_todo_skeleton_iface_init (GoaTodoIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaTodoSkeleton, goa_todo_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaTodoSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TODO, goa_todo_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaTodoSkeleton, goa_todo_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_TODO, goa_todo_skeleton_iface_init))

#endif
static void
goa_todo_skeleton_finalize (GObject *object)
{
  GoaTodoSkeleton *skeleton = GOA_TODO_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_todo_skeleton_parent_class)->finalize (object);
}

static void
goa_todo_skeleton_init (GoaTodoSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_todo_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_TODO_SKELETON, GoaTodoSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_todo_skeleton_class_init (GoaTodoSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_todo_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_todo_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_todo_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_todo_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_todo_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaTodoSkeletonPrivate));
#endif
}

static void
goa_todo_skeleton_iface_init (GoaTodoIface *iface)
{
}

/**
 * goa_todo_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link>.
 *
 * Returns: (transfer full) (type GoaTodoSkeleton): The skeleton object.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *
goa_todo_skeleton_new (void)
{
  return GOA_TODO (g_object_new (GOA_TYPE_TODO_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.ReadLater
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaReadLater
 * @title: GoaReadLater
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.ReadLater D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.ReadLater ---- */

static const GDBusAnnotationInfo _goa_read_later_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _goa_read_later_annotation_info_pointers[] =
{
  &_goa_read_later_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _goa_read_later_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.ReadLater",
    NULL,
    NULL,
    NULL,
    (GDBusAnnotationInfo **) &_goa_read_later_annotation_info_pointers
  },
  "read-later",
};


/**
 * goa_read_later_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GDBusInterfaceInfo *
goa_read_later_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_read_later_interface_info.parent_struct;
}

/**
 * goa_read_later_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaReadLater interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
guint
goa_read_later_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaReadLater:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link>.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaReadLaterIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link>.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

typedef GoaReadLaterIface GoaReadLaterInterface;
G_DEFINE_INTERFACE (GoaReadLater, goa_read_later, G_TYPE_OBJECT)

static void
goa_read_later_default_init (GoaReadLaterIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaReadLaterProxy:
 *
 * The #GoaReadLaterProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaReadLaterProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaReadLaterProxy.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _GoaReadLaterProxyPrivate
{
  GData *qdata;
};

static void goa_read_later_proxy_iface_init (GoaReadLaterIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaReadLaterProxy, goa_read_later_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaReadLaterProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_READ_LATER, goa_read_later_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaReadLaterProxy, goa_read_later_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_READ_LATER, goa_read_later_proxy_iface_init))

#endif
static void
goa_read_later_proxy_finalize (GObject *object)
{
  GoaReadLaterProxy *proxy = GOA_READ_LATER_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_read_later_proxy_parent_class)->finalize (object);
}

static void
goa_read_later_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_read_later_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_read_later_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_read_later_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_READ_LATER);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_READ_LATER);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_read_later_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaReadLaterProxy *proxy = GOA_READ_LATER_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_read_later_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_read_later_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_read_later_proxy_init (GoaReadLaterProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_read_later_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_READ_LATER_PROXY, GoaReadLaterProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_read_later_interface_info ());
}

static void
goa_read_later_proxy_class_init (GoaReadLaterProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_read_later_proxy_finalize;
  gobject_class->get_property = goa_read_later_proxy_get_property;
  gobject_class->set_property = goa_read_later_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_read_later_proxy_g_signal;
  proxy_class->g_properties_changed = goa_read_later_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaReadLaterProxyPrivate));
#endif
}

static void
goa_read_later_proxy_iface_init (GoaReadLaterIface *iface)
{
}

/**
 * goa_read_later_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_read_later_proxy_new_finish() to get the result of the operation.
 *
 * See goa_read_later_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
goa_read_later_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_READ_LATER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.ReadLater", NULL);
}

/**
 * goa_read_later_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_read_later_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_read_later_proxy_new().
 *
 * Returns: (transfer full) (type GoaReadLaterProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *
goa_read_later_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_READ_LATER (ret);
  else
    return NULL;
}

/**
 * goa_read_later_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_read_later_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaReadLaterProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *
goa_read_later_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_READ_LATER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.ReadLater", NULL);
  if (ret != NULL)
    return GOA_READ_LATER (ret);
  else
    return NULL;
}


/**
 * goa_read_later_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_read_later_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_read_later_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_read_later_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
goa_read_later_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_READ_LATER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.ReadLater", NULL);
}

/**
 * goa_read_later_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_read_later_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_read_later_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaReadLaterProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *
goa_read_later_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_READ_LATER (ret);
  else
    return NULL;
}

/**
 * goa_read_later_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_read_later_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_read_later_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaReadLaterProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *
goa_read_later_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_READ_LATER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.ReadLater", NULL);
  if (ret != NULL)
    return GOA_READ_LATER (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaReadLaterSkeleton:
 *
 * The #GoaReadLaterSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * GoaReadLaterSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaReadLaterSkeleton.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _GoaReadLaterSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_read_later_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaReadLaterSkeleton *skeleton = GOA_READ_LATER_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_READ_LATER);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_READ_LATER);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_read_later_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaReadLaterSkeleton *skeleton = GOA_READ_LATER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_read_later_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_read_later_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaReadLaterSkeleton *skeleton = GOA_READ_LATER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_read_later_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_read_later_skeleton_vtable =
{
  _goa_read_later_skeleton_handle_method_call,
  _goa_read_later_skeleton_handle_get_property,
  _goa_read_later_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_read_later_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_read_later_interface_info ();
}

static GDBusInterfaceVTable *
goa_read_later_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_read_later_skeleton_vtable;
}

static GVariant *
goa_read_later_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaReadLaterSkeleton *skeleton = GOA_READ_LATER_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_read_later_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_read_later_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_read_later_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_read_later_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.ReadLater", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_read_later_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_read_later_skeleton_iface_init (GoaReadLaterIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaReadLaterSkeleton, goa_read_later_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaReadLaterSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_READ_LATER, goa_read_later_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaReadLaterSkeleton, goa_read_later_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_READ_LATER, goa_read_later_skeleton_iface_init))

#endif
static void
goa_read_later_skeleton_finalize (GObject *object)
{
  GoaReadLaterSkeleton *skeleton = GOA_READ_LATER_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_read_later_skeleton_parent_class)->finalize (object);
}

static void
goa_read_later_skeleton_init (GoaReadLaterSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_read_later_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_READ_LATER_SKELETON, GoaReadLaterSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_read_later_skeleton_class_init (GoaReadLaterSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_read_later_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_read_later_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_read_later_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_read_later_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_read_later_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaReadLaterSkeletonPrivate));
#endif
}

static void
goa_read_later_skeleton_iface_init (GoaReadLaterIface *iface)
{
}

/**
 * goa_read_later_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link>.
 *
 * Returns: (transfer full) (type GoaReadLaterSkeleton): The skeleton object.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *
goa_read_later_skeleton_new (void)
{
  return GOA_READ_LATER (g_object_new (GOA_TYPE_READ_LATER_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.gnome.OnlineAccounts.Printers
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaPrinters
 * @title: GoaPrinters
 * @short_description: Generated C code for the org.gnome.OnlineAccounts.Printers D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.gnome.OnlineAccounts.Printers ---- */

static const _ExtendedGDBusInterfaceInfo _goa_printers_interface_info =
{
  {
    -1,
    (gchar *) "org.gnome.OnlineAccounts.Printers",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "printers",
};


/**
 * goa_printers_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 3.12.0
 */
GDBusInterfaceInfo *
goa_printers_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_goa_printers_interface_info.parent_struct;
}

/**
 * goa_printers_override_properties:
 * @klass: The class structure for a #GObject derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #GoaPrinters interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Since: 3.12.0
 */
guint
goa_printers_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * GoaPrinters:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link>.
 *
 * Since: 3.12.0
 */

/**
 * GoaPrintersIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link>.
 *
 * Since: 3.12.0
 */

typedef GoaPrintersIface GoaPrintersInterface;
G_DEFINE_INTERFACE (GoaPrinters, goa_printers, G_TYPE_OBJECT)

static void
goa_printers_default_init (GoaPrintersIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * GoaPrintersProxy:
 *
 * The #GoaPrintersProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.12.0
 */

/**
 * GoaPrintersProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPrintersProxy.
 *
 * Since: 3.12.0
 */

struct _GoaPrintersProxyPrivate
{
  GData *qdata;
};

static void goa_printers_proxy_iface_init (GoaPrintersIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaPrintersProxy, goa_printers_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (GoaPrintersProxy)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PRINTERS, goa_printers_proxy_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaPrintersProxy, goa_printers_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PRINTERS, goa_printers_proxy_iface_init))

#endif
static void
goa_printers_proxy_finalize (GObject *object)
{
  GoaPrintersProxy *proxy = GOA_PRINTERS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (goa_printers_proxy_parent_class)->finalize (object);
}

static void
goa_printers_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_printers_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
goa_printers_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  gsize n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_goa_printers_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], GOA_TYPE_PRINTERS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PRINTERS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
goa_printers_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  GoaPrintersProxy *proxy = GOA_PRINTERS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_printers_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_printers_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
goa_printers_proxy_init (GoaPrintersProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = goa_printers_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, GOA_TYPE_PRINTERS_PROXY, GoaPrintersProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), goa_printers_interface_info ());
}

static void
goa_printers_proxy_class_init (GoaPrintersProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = goa_printers_proxy_finalize;
  gobject_class->get_property = goa_printers_proxy_get_property;
  gobject_class->set_property = goa_printers_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = goa_printers_proxy_g_signal;
  proxy_class->g_properties_changed = goa_printers_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaPrintersProxyPrivate));
#endif
}

static void
goa_printers_proxy_iface_init (GoaPrintersIface *iface)
{
}

/**
 * goa_printers_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_printers_proxy_new_finish() to get the result of the operation.
 *
 * See goa_printers_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.12.0
 */
void
goa_printers_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PRINTERS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Printers", NULL);
}

/**
 * goa_printers_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_printers_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_printers_proxy_new().
 *
 * Returns: (transfer full) (type GoaPrintersProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 */
GoaPrinters *
goa_printers_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PRINTERS (ret);
  else
    return NULL;
}

/**
 * goa_printers_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_printers_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPrintersProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 */
GoaPrinters *
goa_printers_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PRINTERS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Printers", NULL);
  if (ret != NULL)
    return GOA_PRINTERS (ret);
  else
    return NULL;
}


/**
 * goa_printers_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_printers_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_printers_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_printers_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 3.12.0
 */
void
goa_printers_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (GOA_TYPE_PRINTERS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Printers", NULL);
}

/**
 * goa_printers_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_printers_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_printers_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type GoaPrintersProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 */
GoaPrinters *
goa_printers_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return GOA_PRINTERS (ret);
  else
    return NULL;
}

/**
 * goa_printers_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_printers_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_printers_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaPrintersProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 3.12.0
 */
GoaPrinters *
goa_printers_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_PRINTERS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.gnome.OnlineAccounts.Printers", NULL);
  if (ret != NULL)
    return GOA_PRINTERS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * GoaPrintersSkeleton:
 *
 * The #GoaPrintersSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 3.12.0
 */

/**
 * GoaPrintersSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaPrintersSkeleton.
 *
 * Since: 3.12.0
 */

struct _GoaPrintersSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_goa_printers_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  GoaPrintersSkeleton *skeleton = GOA_PRINTERS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  gsize num_params;
  guint num_extra;
  gsize n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], GOA_TYPE_PRINTERS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, GOA_TYPE_PRINTERS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_goa_printers_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  GoaPrintersSkeleton *skeleton = GOA_PRINTERS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_printers_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_goa_printers_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  GoaPrintersSkeleton *skeleton = GOA_PRINTERS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_goa_printers_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _goa_printers_skeleton_vtable =
{
  _goa_printers_skeleton_handle_method_call,
  _goa_printers_skeleton_handle_get_property,
  _goa_printers_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
goa_printers_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return goa_printers_interface_info ();
}

static GDBusInterfaceVTable *
goa_printers_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_goa_printers_skeleton_vtable;
}

static GVariant *
goa_printers_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  GoaPrintersSkeleton *skeleton = GOA_PRINTERS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_goa_printers_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _goa_printers_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _goa_printers_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _goa_printers_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.gnome.OnlineAccounts.Printers", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
goa_printers_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void goa_printers_skeleton_iface_init (GoaPrintersIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (GoaPrintersSkeleton, goa_printers_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (GoaPrintersSkeleton)
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PRINTERS, goa_printers_skeleton_iface_init))

#else
G_DEFINE_TYPE_WITH_CODE (GoaPrintersSkeleton, goa_printers_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_PRINTERS, goa_printers_skeleton_iface_init))

#endif
static void
goa_printers_skeleton_finalize (GObject *object)
{
  GoaPrintersSkeleton *skeleton = GOA_PRINTERS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (goa_printers_skeleton_parent_class)->finalize (object);
}

static void
goa_printers_skeleton_init (GoaPrintersSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = goa_printers_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, GOA_TYPE_PRINTERS_SKELETON, GoaPrintersSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
goa_printers_skeleton_class_init (GoaPrintersSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = goa_printers_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = goa_printers_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = goa_printers_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = goa_printers_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = goa_printers_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (GoaPrintersSkeletonPrivate));
#endif
}

static void
goa_printers_skeleton_iface_init (GoaPrintersIface *iface)
{
}

/**
 * goa_printers_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link>.
 *
 * Returns: (transfer full) (type GoaPrintersSkeleton): The skeleton object.
 *
 * Since: 3.12.0
 */
GoaPrinters *
goa_printers_skeleton_new (void)
{
  return GOA_PRINTERS (g_object_new (GOA_TYPE_PRINTERS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for Object, ObjectProxy and ObjectSkeleton
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaObject
 * @title: GoaObject
 * @short_description: Specialized GDBusObject types
 *
 * This section contains the #GoaObject, #GoaObjectProxy, and #GoaObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.
 */

/**
 * GoaObject:
 *
 * The #GoaObject type is a specialized container of interfaces.
 */

/**
 * GoaObjectIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the #GoaObject interface.
 */

typedef GoaObjectIface GoaObjectInterface;
G_DEFINE_INTERFACE_WITH_CODE (GoaObject, goa_object, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT);)

static void
goa_object_default_init (GoaObjectIface *iface)
{
  /**
   * GoaObject:account:
   *
   * The #GoaAccount instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("account", "account", "account", GOA_TYPE_ACCOUNT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:oauth2-based:
   *
   * The #GoaOAuth2Based instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("oauth2-based", "oauth2-based", "oauth2-based", GOA_TYPE_OAUTH2_BASED, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:oauth-based:
   *
   * The #GoaOAuthBased instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("oauth-based", "oauth-based", "oauth-based", GOA_TYPE_OAUTH_BASED, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:password-based:
   *
   * The #GoaPasswordBased instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("password-based", "password-based", "password-based", GOA_TYPE_PASSWORD_BASED, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:manager:
   *
   * The #GoaManager instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("manager", "manager", "manager", GOA_TYPE_MANAGER, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:mail:
   *
   * The #GoaMail instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("mail", "mail", "mail", GOA_TYPE_MAIL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:calendar:
   *
   * The #GoaCalendar instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("calendar", "calendar", "calendar", GOA_TYPE_CALENDAR, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:contacts:
   *
   * The #GoaContacts instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("contacts", "contacts", "contacts", GOA_TYPE_CONTACTS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:chat:
   *
   * The #GoaChat instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("chat", "chat", "chat", GOA_TYPE_CHAT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:documents:
   *
   * The #GoaDocuments instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Deprecated: The D-Bus interface has been deprecated.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("documents", "documents", "documents", GOA_TYPE_DOCUMENTS, G_PARAM_DEPRECATED | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:maps:
   *
   * The #GoaMaps instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.14.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("maps", "maps", "maps", GOA_TYPE_MAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:music:
   *
   * The #GoaMusic instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.18.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("music", "music", "music", GOA_TYPE_MUSIC, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:photos:
   *
   * The #GoaPhotos instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("photos", "photos", "photos", GOA_TYPE_PHOTOS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:files:
   *
   * The #GoaFiles instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.8.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("files", "files", "files", GOA_TYPE_FILES, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:exchange:
   *
   * The #GoaExchange instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("exchange", "exchange", "exchange", GOA_TYPE_EXCHANGE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:media-server:
   *
   * The #GoaMediaServer instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.14
   */
  g_object_interface_install_property (iface, g_param_spec_object ("media-server", "media-server", "media-server", GOA_TYPE_MEDIA_SERVER, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:ticketing:
   *
   * The #GoaTicketing instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.6.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("ticketing", "ticketing", "ticketing", GOA_TYPE_TICKETING, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:todo:
   *
   * The #GoaTodo instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.26.0
   *
   * Deprecated: The D-Bus interface has been deprecated.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("todo", "todo", "todo", GOA_TYPE_TODO, G_PARAM_DEPRECATED | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:read-later:
   *
   * The #GoaReadLater instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.12.0
   *
   * Deprecated: The D-Bus interface has been deprecated.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("read-later", "read-later", "read-later", GOA_TYPE_READ_LATER, G_PARAM_DEPRECATED | G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

  /**
   * GoaObject:printers:
   *
   * The #GoaPrinters instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 3.12.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("printers", "printers", "printers", GOA_TYPE_PRINTERS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));

}

/**
 * goa_object_get_account:
 * @object: A #GoaObject.
 *
 * Gets the #GoaAccount instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaAccount that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaAccount *goa_object_get_account (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
  if (ret == NULL)
    return NULL;
  return GOA_ACCOUNT (ret);
}

/**
 * goa_object_get_oauth2_based:
 * @object: A #GoaObject.
 *
 * Gets the #GoaOAuth2Based instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaOAuth2Based that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaOAuth2Based *goa_object_get_oauth2_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
  if (ret == NULL)
    return NULL;
  return GOA_OAUTH2_BASED (ret);
}

/**
 * goa_object_get_oauth_based:
 * @object: A #GoaObject.
 *
 * Gets the #GoaOAuthBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaOAuthBased that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaOAuthBased *goa_object_get_oauth_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
  if (ret == NULL)
    return NULL;
  return GOA_OAUTH_BASED (ret);
}

/**
 * goa_object_get_password_based:
 * @object: A #GoaObject.
 *
 * Gets the #GoaPasswordBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaPasswordBased that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *goa_object_get_password_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
  if (ret == NULL)
    return NULL;
  return GOA_PASSWORD_BASED (ret);
}

/**
 * goa_object_get_manager:
 * @object: A #GoaObject.
 *
 * Gets the #GoaManager instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaManager that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaManager *goa_object_get_manager (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
  if (ret == NULL)
    return NULL;
  return GOA_MANAGER (ret);
}

/**
 * goa_object_get_mail:
 * @object: A #GoaObject.
 *
 * Gets the #GoaMail instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaMail that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaMail *goa_object_get_mail (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
  if (ret == NULL)
    return NULL;
  return GOA_MAIL (ret);
}

/**
 * goa_object_get_calendar:
 * @object: A #GoaObject.
 *
 * Gets the #GoaCalendar instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaCalendar that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaCalendar *goa_object_get_calendar (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
  if (ret == NULL)
    return NULL;
  return GOA_CALENDAR (ret);
}

/**
 * goa_object_get_contacts:
 * @object: A #GoaObject.
 *
 * Gets the #GoaContacts instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaContacts that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaContacts *goa_object_get_contacts (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
  if (ret == NULL)
    return NULL;
  return GOA_CONTACTS (ret);
}

/**
 * goa_object_get_chat:
 * @object: A #GoaObject.
 *
 * Gets the #GoaChat instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaChat that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
GoaChat *goa_object_get_chat (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
  if (ret == NULL)
    return NULL;
  return GOA_CHAT (ret);
}

/**
 * goa_object_get_documents:
 * @object: A #GoaObject.
 *
 * Gets the #GoaDocuments instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaDocuments that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *goa_object_get_documents (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
  if (ret == NULL)
    return NULL;
  return GOA_DOCUMENTS (ret);
}

/**
 * goa_object_get_maps:
 * @object: A #GoaObject.
 *
 * Gets the #GoaMaps instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaMaps that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.14.0
 */
GoaMaps *goa_object_get_maps (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Maps");
  if (ret == NULL)
    return NULL;
  return GOA_MAPS (ret);
}

/**
 * goa_object_get_music:
 * @object: A #GoaObject.
 *
 * Gets the #GoaMusic instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaMusic that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.18.0
 */
GoaMusic *goa_object_get_music (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Music");
  if (ret == NULL)
    return NULL;
  return GOA_MUSIC (ret);
}

/**
 * goa_object_get_photos:
 * @object: A #GoaObject.
 *
 * Gets the #GoaPhotos instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaPhotos that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.8.0
 */
GoaPhotos *goa_object_get_photos (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Photos");
  if (ret == NULL)
    return NULL;
  return GOA_PHOTOS (ret);
}

/**
 * goa_object_get_files:
 * @object: A #GoaObject.
 *
 * Gets the #GoaFiles instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaFiles that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.8.0
 */
GoaFiles *goa_object_get_files (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Files");
  if (ret == NULL)
    return NULL;
  return GOA_FILES (ret);
}

/**
 * goa_object_get_exchange:
 * @object: A #GoaObject.
 *
 * Gets the #GoaExchange instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaExchange that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.6.0
 */
GoaExchange *goa_object_get_exchange (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
  if (ret == NULL)
    return NULL;
  return GOA_EXCHANGE (ret);
}

/**
 * goa_object_get_media_server:
 * @object: A #GoaObject.
 *
 * Gets the #GoaMediaServer instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaMediaServer that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.14
 */
GoaMediaServer *goa_object_get_media_server (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.MediaServer");
  if (ret == NULL)
    return NULL;
  return GOA_MEDIA_SERVER (ret);
}

/**
 * goa_object_get_ticketing:
 * @object: A #GoaObject.
 *
 * Gets the #GoaTicketing instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaTicketing that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.6.0
 */
GoaTicketing *goa_object_get_ticketing (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
  if (ret == NULL)
    return NULL;
  return GOA_TICKETING (ret);
}

/**
 * goa_object_get_todo:
 * @object: A #GoaObject.
 *
 * Gets the #GoaTodo instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaTodo that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *goa_object_get_todo (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Todo");
  if (ret == NULL)
    return NULL;
  return GOA_TODO (ret);
}

/**
 * goa_object_get_read_later:
 * @object: A #GoaObject.
 *
 * Gets the #GoaReadLater instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaReadLater that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *goa_object_get_read_later (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.ReadLater");
  if (ret == NULL)
    return NULL;
  return GOA_READ_LATER (ret);
}

/**
 * goa_object_get_printers:
 * @object: A #GoaObject.
 *
 * Gets the #GoaPrinters instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link> on @object, if any.
 *
 * Returns: (transfer full) (nullable): A #GoaPrinters that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 3.12.0
 */
GoaPrinters *goa_object_get_printers (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Printers");
  if (ret == NULL)
    return NULL;
  return GOA_PRINTERS (ret);
}


/**
 * goa_object_peek_account: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_account() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaAccount or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaAccount *goa_object_peek_account (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_ACCOUNT (ret);
}

/**
 * goa_object_peek_oauth2_based: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_oauth2_based() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaOAuth2Based or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaOAuth2Based *goa_object_peek_oauth2_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_OAUTH2_BASED (ret);
}

/**
 * goa_object_peek_oauth_based: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_oauth_based() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaOAuthBased or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaOAuthBased *goa_object_peek_oauth_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_OAUTH_BASED (ret);
}

/**
 * goa_object_peek_password_based: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_password_based() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaPasswordBased or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.6.0
 */
GoaPasswordBased *goa_object_peek_password_based (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_PASSWORD_BASED (ret);
}

/**
 * goa_object_peek_manager: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_manager() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaManager or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaManager *goa_object_peek_manager (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MANAGER (ret);
}

/**
 * goa_object_peek_mail: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_mail() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaMail or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaMail *goa_object_peek_mail (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MAIL (ret);
}

/**
 * goa_object_peek_calendar: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_calendar() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaCalendar or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaCalendar *goa_object_peek_calendar (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_CALENDAR (ret);
}

/**
 * goa_object_peek_contacts: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_contacts() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaContacts or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaContacts *goa_object_peek_contacts (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_CONTACTS (ret);
}

/**
 * goa_object_peek_chat: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_chat() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaChat or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
GoaChat *goa_object_peek_chat (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_CHAT (ret);
}

/**
 * goa_object_peek_documents: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_documents() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaDocuments or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaDocuments *goa_object_peek_documents (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_DOCUMENTS (ret);
}

/**
 * goa_object_peek_maps: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_maps() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaMaps or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.14.0
 */
GoaMaps *goa_object_peek_maps (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Maps");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MAPS (ret);
}

/**
 * goa_object_peek_music: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_music() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaMusic or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.18.0
 */
GoaMusic *goa_object_peek_music (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Music");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MUSIC (ret);
}

/**
 * goa_object_peek_photos: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_photos() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaPhotos or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.8.0
 */
GoaPhotos *goa_object_peek_photos (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Photos");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_PHOTOS (ret);
}

/**
 * goa_object_peek_files: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_files() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaFiles or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.8.0
 */
GoaFiles *goa_object_peek_files (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Files");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_FILES (ret);
}

/**
 * goa_object_peek_exchange: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_exchange() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaExchange or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.6.0
 */
GoaExchange *goa_object_peek_exchange (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_EXCHANGE (ret);
}

/**
 * goa_object_peek_media_server: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_media_server() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaMediaServer or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.14
 */
GoaMediaServer *goa_object_peek_media_server (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.MediaServer");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_MEDIA_SERVER (ret);
}

/**
 * goa_object_peek_ticketing: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_ticketing() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaTicketing or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.6.0
 */
GoaTicketing *goa_object_peek_ticketing (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_TICKETING (ret);
}

/**
 * goa_object_peek_todo: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_todo() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaTodo or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaTodo *goa_object_peek_todo (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Todo");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_TODO (ret);
}

/**
 * goa_object_peek_read_later: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_read_later() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaReadLater or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GoaReadLater *goa_object_peek_read_later (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.ReadLater");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_READ_LATER (ret);
}

/**
 * goa_object_peek_printers: (skip)
 * @object: A #GoaObject.
 *
 * Like goa_object_get_printers() but doesn't increase the reference count on the returned object.
 *
 * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.
 *
 * Returns: (transfer none) (nullable): A #GoaPrinters or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 3.12.0
 */
GoaPrinters *goa_object_peek_printers (GoaObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Printers");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return GOA_PRINTERS (ret);
}


static void
goa_object_notify (GDBusObject *object, GDBusInterface *interface)
{
  _ExtendedGDBusInterfaceInfo *info = (_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface);
  /* info can be NULL if the other end is using a D-Bus interface we don't know
   * anything about, for example old generated code in this process talking to
   * newer generated code in the other process. */
  if (info != NULL)
    g_object_notify (G_OBJECT (object), info->hyphen_name);
}

/**
 * GoaObjectProxy:
 *
 * The #GoaObjectProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaObjectProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaObjectProxy.
 */

static void
goa_object_proxy__goa_object_iface_init (GoaObjectIface *iface G_GNUC_UNUSED)
{
}

static void
goa_object_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = goa_object_notify;
  iface->interface_removed = goa_object_notify;
}


G_DEFINE_TYPE_WITH_CODE (GoaObjectProxy, goa_object_proxy, G_TYPE_DBUS_OBJECT_PROXY,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OBJECT, goa_object_proxy__goa_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, goa_object_proxy__g_dbus_object_iface_init))

static void
goa_object_proxy_init (GoaObjectProxy *object G_GNUC_UNUSED)
{
}

static void
goa_object_proxy_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value G_GNUC_UNUSED,
  GParamSpec   *pspec)
{
  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
}

static void
goa_object_proxy_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaObjectProxy *object = GOA_OBJECT_PROXY (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Maps");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Music");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Photos");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Files");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.MediaServer");
      g_value_take_object (value, interface);
      break;

    case 17:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
      g_value_take_object (value, interface);
      break;

    case 18:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Todo");
      g_value_take_object (value, interface);
      break;

    case 19:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.ReadLater");
      g_value_take_object (value, interface);
      break;

    case 20:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Printers");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
goa_object_proxy_class_init (GoaObjectProxyClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = goa_object_proxy_set_property;
  gobject_class->get_property = goa_object_proxy_get_property;

  g_object_class_override_property (gobject_class, 1, "account");
  g_object_class_override_property (gobject_class, 2, "oauth2-based");
  g_object_class_override_property (gobject_class, 3, "oauth-based");
  g_object_class_override_property (gobject_class, 4, "password-based");
  g_object_class_override_property (gobject_class, 5, "manager");
  g_object_class_override_property (gobject_class, 6, "mail");
  g_object_class_override_property (gobject_class, 7, "calendar");
  g_object_class_override_property (gobject_class, 8, "contacts");
  g_object_class_override_property (gobject_class, 9, "chat");
  g_object_class_override_property (gobject_class, 10, "documents");
  g_object_class_override_property (gobject_class, 11, "maps");
  g_object_class_override_property (gobject_class, 12, "music");
  g_object_class_override_property (gobject_class, 13, "photos");
  g_object_class_override_property (gobject_class, 14, "files");
  g_object_class_override_property (gobject_class, 15, "exchange");
  g_object_class_override_property (gobject_class, 16, "media-server");
  g_object_class_override_property (gobject_class, 17, "ticketing");
  g_object_class_override_property (gobject_class, 18, "todo");
  g_object_class_override_property (gobject_class, 19, "read-later");
  g_object_class_override_property (gobject_class, 20, "printers");
}

/**
 * goa_object_proxy_new:
 * @connection: A #GDBusConnection.
 * @object_path: An object path.
 *
 * Creates a new proxy object.
 *
 * Returns: (transfer full): The proxy object.
 */
GoaObjectProxy *
goa_object_proxy_new (GDBusConnection *connection,
  const gchar *object_path)
{
  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return GOA_OBJECT_PROXY (g_object_new (GOA_TYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));
}

/**
 * GoaObjectSkeleton:
 *
 * The #GoaObjectSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaObjectSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaObjectSkeleton.
 */

static void
goa_object_skeleton__goa_object_iface_init (GoaObjectIface *iface G_GNUC_UNUSED)
{
}


static void
goa_object_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = goa_object_notify;
  iface->interface_removed = goa_object_notify;
}

G_DEFINE_TYPE_WITH_CODE (GoaObjectSkeleton, goa_object_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,
                         G_IMPLEMENT_INTERFACE (GOA_TYPE_OBJECT, goa_object_skeleton__goa_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, goa_object_skeleton__g_dbus_object_iface_init))

static void
goa_object_skeleton_init (GoaObjectSkeleton *object G_GNUC_UNUSED)
{
}

static void
goa_object_skeleton_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  GoaObjectSkeleton *object = GOA_OBJECT_SKELETON (gobject);
  GDBusInterfaceSkeleton *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_ACCOUNT (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Account");
        }
      break;

    case 2:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_OAUTH2_BASED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.OAuth2Based");
        }
      break;

    case 3:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_OAUTH_BASED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.OAuthBased");
        }
      break;

    case 4:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_PASSWORD_BASED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.PasswordBased");
        }
      break;

    case 5:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MANAGER (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Manager");
        }
      break;

    case 6:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MAIL (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Mail");
        }
      break;

    case 7:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_CALENDAR (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Calendar");
        }
      break;

    case 8:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_CONTACTS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Contacts");
        }
      break;

    case 9:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_CHAT (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Chat");
        }
      break;

    case 10:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_DOCUMENTS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Documents");
        }
      break;

    case 11:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MAPS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Maps");
        }
      break;

    case 12:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MUSIC (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Music");
        }
      break;

    case 13:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_PHOTOS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Photos");
        }
      break;

    case 14:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_FILES (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Files");
        }
      break;

    case 15:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_EXCHANGE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Exchange");
        }
      break;

    case 16:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_MEDIA_SERVER (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.MediaServer");
        }
      break;

    case 17:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_TICKETING (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Ticketing");
        }
      break;

    case 18:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_TODO (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Todo");
        }
      break;

    case 19:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_READ_LATER (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.ReadLater");
        }
      break;

    case 20:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (GOA_IS_PRINTERS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.gnome.OnlineAccounts.Printers");
        }
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
goa_object_skeleton_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  GoaObjectSkeleton *object = GOA_OBJECT_SKELETON (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Account");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuth2Based");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.OAuthBased");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.PasswordBased");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Manager");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Mail");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Calendar");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Contacts");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Chat");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Documents");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Maps");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Music");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Photos");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Files");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Exchange");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.MediaServer");
      g_value_take_object (value, interface);
      break;

    case 17:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Ticketing");
      g_value_take_object (value, interface);
      break;

    case 18:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Todo");
      g_value_take_object (value, interface);
      break;

    case 19:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.ReadLater");
      g_value_take_object (value, interface);
      break;

    case 20:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.gnome.OnlineAccounts.Printers");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
goa_object_skeleton_class_init (GoaObjectSkeletonClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = goa_object_skeleton_set_property;
  gobject_class->get_property = goa_object_skeleton_get_property;

  g_object_class_override_property (gobject_class, 1, "account");
  g_object_class_override_property (gobject_class, 2, "oauth2-based");
  g_object_class_override_property (gobject_class, 3, "oauth-based");
  g_object_class_override_property (gobject_class, 4, "password-based");
  g_object_class_override_property (gobject_class, 5, "manager");
  g_object_class_override_property (gobject_class, 6, "mail");
  g_object_class_override_property (gobject_class, 7, "calendar");
  g_object_class_override_property (gobject_class, 8, "contacts");
  g_object_class_override_property (gobject_class, 9, "chat");
  g_object_class_override_property (gobject_class, 10, "documents");
  g_object_class_override_property (gobject_class, 11, "maps");
  g_object_class_override_property (gobject_class, 12, "music");
  g_object_class_override_property (gobject_class, 13, "photos");
  g_object_class_override_property (gobject_class, 14, "files");
  g_object_class_override_property (gobject_class, 15, "exchange");
  g_object_class_override_property (gobject_class, 16, "media-server");
  g_object_class_override_property (gobject_class, 17, "ticketing");
  g_object_class_override_property (gobject_class, 18, "todo");
  g_object_class_override_property (gobject_class, 19, "read-later");
  g_object_class_override_property (gobject_class, 20, "printers");
}

/**
 * goa_object_skeleton_new:
 * @object_path: An object path.
 *
 * Creates a new skeleton object.
 *
 * Returns: (transfer full): The skeleton object.
 */
GoaObjectSkeleton *
goa_object_skeleton_new (const gchar *object_path)
{
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return GOA_OBJECT_SKELETON (g_object_new (GOA_TYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));
}

/**
 * goa_object_skeleton_set_account:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaAccount or %NULL to clear the interface.
 *
 * Sets the #GoaAccount instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Account.top_of_page">org.gnome.OnlineAccounts.Account</link> on @object.
 */
void goa_object_skeleton_set_account (GoaObjectSkeleton *object, GoaAccount *interface_)
{
  g_object_set (G_OBJECT (object), "account", interface_, NULL);
}

/**
 * goa_object_skeleton_set_oauth2_based:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaOAuth2Based or %NULL to clear the interface.
 *
 * Sets the #GoaOAuth2Based instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuth2Based.top_of_page">org.gnome.OnlineAccounts.OAuth2Based</link> on @object.
 */
void goa_object_skeleton_set_oauth2_based (GoaObjectSkeleton *object, GoaOAuth2Based *interface_)
{
  g_object_set (G_OBJECT (object), "oauth2-based", interface_, NULL);
}

/**
 * goa_object_skeleton_set_oauth_based:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaOAuthBased or %NULL to clear the interface.
 *
 * Sets the #GoaOAuthBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-OAuthBased.top_of_page">org.gnome.OnlineAccounts.OAuthBased</link> on @object.
 */
void goa_object_skeleton_set_oauth_based (GoaObjectSkeleton *object, GoaOAuthBased *interface_)
{
  g_object_set (G_OBJECT (object), "oauth-based", interface_, NULL);
}

/**
 * goa_object_skeleton_set_password_based:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaPasswordBased or %NULL to clear the interface.
 *
 * Sets the #GoaPasswordBased instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-PasswordBased.top_of_page">org.gnome.OnlineAccounts.PasswordBased</link> on @object.
 *
 * Since: 3.6.0
 */
void goa_object_skeleton_set_password_based (GoaObjectSkeleton *object, GoaPasswordBased *interface_)
{
  g_object_set (G_OBJECT (object), "password-based", interface_, NULL);
}

/**
 * goa_object_skeleton_set_manager:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaManager or %NULL to clear the interface.
 *
 * Sets the #GoaManager instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Manager.top_of_page">org.gnome.OnlineAccounts.Manager</link> on @object.
 */
void goa_object_skeleton_set_manager (GoaObjectSkeleton *object, GoaManager *interface_)
{
  g_object_set (G_OBJECT (object), "manager", interface_, NULL);
}

/**
 * goa_object_skeleton_set_mail:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaMail or %NULL to clear the interface.
 *
 * Sets the #GoaMail instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Mail.top_of_page">org.gnome.OnlineAccounts.Mail</link> on @object.
 */
void goa_object_skeleton_set_mail (GoaObjectSkeleton *object, GoaMail *interface_)
{
  g_object_set (G_OBJECT (object), "mail", interface_, NULL);
}

/**
 * goa_object_skeleton_set_calendar:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaCalendar or %NULL to clear the interface.
 *
 * Sets the #GoaCalendar instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Calendar.top_of_page">org.gnome.OnlineAccounts.Calendar</link> on @object.
 */
void goa_object_skeleton_set_calendar (GoaObjectSkeleton *object, GoaCalendar *interface_)
{
  g_object_set (G_OBJECT (object), "calendar", interface_, NULL);
}

/**
 * goa_object_skeleton_set_contacts:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaContacts or %NULL to clear the interface.
 *
 * Sets the #GoaContacts instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Contacts.top_of_page">org.gnome.OnlineAccounts.Contacts</link> on @object.
 */
void goa_object_skeleton_set_contacts (GoaObjectSkeleton *object, GoaContacts *interface_)
{
  g_object_set (G_OBJECT (object), "contacts", interface_, NULL);
}

/**
 * goa_object_skeleton_set_chat:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaChat or %NULL to clear the interface.
 *
 * Sets the #GoaChat instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Chat.top_of_page">org.gnome.OnlineAccounts.Chat</link> on @object.
 */
void goa_object_skeleton_set_chat (GoaObjectSkeleton *object, GoaChat *interface_)
{
  g_object_set (G_OBJECT (object), "chat", interface_, NULL);
}

/**
 * goa_object_skeleton_set_documents:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaDocuments or %NULL to clear the interface.
 *
 * Sets the #GoaDocuments instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Documents.top_of_page">org.gnome.OnlineAccounts.Documents</link> on @object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void goa_object_skeleton_set_documents (GoaObjectSkeleton *object, GoaDocuments *interface_)
{
  g_object_set (G_OBJECT (object), "documents", interface_, NULL);
}

/**
 * goa_object_skeleton_set_maps:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaMaps or %NULL to clear the interface.
 *
 * Sets the #GoaMaps instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Maps.top_of_page">org.gnome.OnlineAccounts.Maps</link> on @object.
 *
 * Since: 3.14.0
 */
void goa_object_skeleton_set_maps (GoaObjectSkeleton *object, GoaMaps *interface_)
{
  g_object_set (G_OBJECT (object), "maps", interface_, NULL);
}

/**
 * goa_object_skeleton_set_music:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaMusic or %NULL to clear the interface.
 *
 * Sets the #GoaMusic instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Music.top_of_page">org.gnome.OnlineAccounts.Music</link> on @object.
 *
 * Since: 3.18.0
 */
void goa_object_skeleton_set_music (GoaObjectSkeleton *object, GoaMusic *interface_)
{
  g_object_set (G_OBJECT (object), "music", interface_, NULL);
}

/**
 * goa_object_skeleton_set_photos:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaPhotos or %NULL to clear the interface.
 *
 * Sets the #GoaPhotos instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Photos.top_of_page">org.gnome.OnlineAccounts.Photos</link> on @object.
 *
 * Since: 3.8.0
 */
void goa_object_skeleton_set_photos (GoaObjectSkeleton *object, GoaPhotos *interface_)
{
  g_object_set (G_OBJECT (object), "photos", interface_, NULL);
}

/**
 * goa_object_skeleton_set_files:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaFiles or %NULL to clear the interface.
 *
 * Sets the #GoaFiles instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Files.top_of_page">org.gnome.OnlineAccounts.Files</link> on @object.
 *
 * Since: 3.8.0
 */
void goa_object_skeleton_set_files (GoaObjectSkeleton *object, GoaFiles *interface_)
{
  g_object_set (G_OBJECT (object), "files", interface_, NULL);
}

/**
 * goa_object_skeleton_set_exchange:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaExchange or %NULL to clear the interface.
 *
 * Sets the #GoaExchange instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Exchange.top_of_page">org.gnome.OnlineAccounts.Exchange</link> on @object.
 *
 * Since: 3.6.0
 */
void goa_object_skeleton_set_exchange (GoaObjectSkeleton *object, GoaExchange *interface_)
{
  g_object_set (G_OBJECT (object), "exchange", interface_, NULL);
}

/**
 * goa_object_skeleton_set_media_server:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaMediaServer or %NULL to clear the interface.
 *
 * Sets the #GoaMediaServer instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-MediaServer.top_of_page">org.gnome.OnlineAccounts.MediaServer</link> on @object.
 *
 * Since: 3.14
 */
void goa_object_skeleton_set_media_server (GoaObjectSkeleton *object, GoaMediaServer *interface_)
{
  g_object_set (G_OBJECT (object), "media-server", interface_, NULL);
}

/**
 * goa_object_skeleton_set_ticketing:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaTicketing or %NULL to clear the interface.
 *
 * Sets the #GoaTicketing instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Ticketing.top_of_page">org.gnome.OnlineAccounts.Ticketing</link> on @object.
 *
 * Since: 3.6.0
 */
void goa_object_skeleton_set_ticketing (GoaObjectSkeleton *object, GoaTicketing *interface_)
{
  g_object_set (G_OBJECT (object), "ticketing", interface_, NULL);
}

/**
 * goa_object_skeleton_set_todo:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaTodo or %NULL to clear the interface.
 *
 * Sets the #GoaTodo instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Todo.top_of_page">org.gnome.OnlineAccounts.Todo</link> on @object.
 *
 * Since: 3.26.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void goa_object_skeleton_set_todo (GoaObjectSkeleton *object, GoaTodo *interface_)
{
  g_object_set (G_OBJECT (object), "todo", interface_, NULL);
}

/**
 * goa_object_skeleton_set_read_later:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaReadLater or %NULL to clear the interface.
 *
 * Sets the #GoaReadLater instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-ReadLater.top_of_page">org.gnome.OnlineAccounts.ReadLater</link> on @object.
 *
 * Since: 3.12.0
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void goa_object_skeleton_set_read_later (GoaObjectSkeleton *object, GoaReadLater *interface_)
{
  g_object_set (G_OBJECT (object), "read-later", interface_, NULL);
}

/**
 * goa_object_skeleton_set_printers:
 * @object: A #GoaObjectSkeleton.
 * @interface_: (nullable): A #GoaPrinters or %NULL to clear the interface.
 *
 * Sets the #GoaPrinters instance for the D-Bus interface <link linkend="gdbus-interface-org-gnome-OnlineAccounts-Printers.top_of_page">org.gnome.OnlineAccounts.Printers</link> on @object.
 *
 * Since: 3.12.0
 */
void goa_object_skeleton_set_printers (GoaObjectSkeleton *object, GoaPrinters *interface_)
{
  g_object_set (G_OBJECT (object), "printers", interface_, NULL);
}


/* ------------------------------------------------------------------------
 * Code for ObjectManager client
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:GoaObjectManagerClient
 * @title: GoaObjectManagerClient
 * @short_description: Generated GDBusObjectManagerClient type
 *
 * This section contains a #GDBusObjectManagerClient that uses goa_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.
 */

/**
 * GoaObjectManagerClient:
 *
 * The #GoaObjectManagerClient structure contains only private data and should only be accessed using the provided API.
 */

/**
 * GoaObjectManagerClientClass:
 * @parent_class: The parent class.
 *
 * Class structure for #GoaObjectManagerClient.
 */

G_DEFINE_TYPE (GoaObjectManagerClient, goa_object_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT)

static void
goa_object_manager_client_init (GoaObjectManagerClient *manager G_GNUC_UNUSED)
{
}

static void
goa_object_manager_client_class_init (GoaObjectManagerClientClass *klass G_GNUC_UNUSED)
{
}

/**
 * goa_object_manager_client_get_proxy_type:
 * @manager: A #GDBusObjectManagerClient.
 * @object_path: The object path of the remote object (unused).
 * @interface_name: (nullable): Interface name of the remote object or %NULL to get the object proxy #GType.
 * @user_data: User data (unused).
 *
 * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy derived and #GDBusProxy derived types.
 *
 * Returns: A #GDBusProxy derived #GType if @interface_name is not %NULL, otherwise the #GType for #GoaObjectProxy.
 */
GType
goa_object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager G_GNUC_UNUSED, const gchar *object_path G_GNUC_UNUSED, const gchar *interface_name, gpointer user_data G_GNUC_UNUSED)
{
  static gsize once_init_value = 0;
  static GHashTable *lookup_hash;
  GType ret;

  if (interface_name == NULL)
    return GOA_TYPE_OBJECT_PROXY;
  if (g_once_init_enter (&once_init_value))
    {
      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Account", GSIZE_TO_POINTER (GOA_TYPE_ACCOUNT_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.OAuth2Based", GSIZE_TO_POINTER (GOA_TYPE_OAUTH2_BASED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.OAuthBased", GSIZE_TO_POINTER (GOA_TYPE_OAUTH_BASED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.PasswordBased", GSIZE_TO_POINTER (GOA_TYPE_PASSWORD_BASED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Manager", GSIZE_TO_POINTER (GOA_TYPE_MANAGER_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Mail", GSIZE_TO_POINTER (GOA_TYPE_MAIL_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Calendar", GSIZE_TO_POINTER (GOA_TYPE_CALENDAR_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Contacts", GSIZE_TO_POINTER (GOA_TYPE_CONTACTS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Chat", GSIZE_TO_POINTER (GOA_TYPE_CHAT_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Documents", GSIZE_TO_POINTER (GOA_TYPE_DOCUMENTS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Maps", GSIZE_TO_POINTER (GOA_TYPE_MAPS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Music", GSIZE_TO_POINTER (GOA_TYPE_MUSIC_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Photos", GSIZE_TO_POINTER (GOA_TYPE_PHOTOS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Files", GSIZE_TO_POINTER (GOA_TYPE_FILES_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Exchange", GSIZE_TO_POINTER (GOA_TYPE_EXCHANGE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.MediaServer", GSIZE_TO_POINTER (GOA_TYPE_MEDIA_SERVER_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Ticketing", GSIZE_TO_POINTER (GOA_TYPE_TICKETING_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Todo", GSIZE_TO_POINTER (GOA_TYPE_TODO_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.ReadLater", GSIZE_TO_POINTER (GOA_TYPE_READ_LATER_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.gnome.OnlineAccounts.Printers", GSIZE_TO_POINTER (GOA_TYPE_PRINTERS_PROXY));
      g_once_init_leave (&once_init_value, 1);
    }
  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));
  if (ret == (GType) 0)
    ret = G_TYPE_DBUS_PROXY;
  return ret;
}

/**
 * goa_object_manager_client_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates #GDBusObjectManagerClient using goa_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_object_manager_client_new_finish() to get the result of the operation.
 *
 * See goa_object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (GOA_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
}

/**
 * goa_object_manager_client_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_object_manager_client_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_object_manager_client_new().
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_object_manager_client_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates #GDBusObjectManagerClient using goa_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_object_manager_client_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


/**
 * goa_object_manager_client_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like goa_object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).
 * You can then call goa_object_manager_client_new_for_bus_finish() to get the result of the operation.
 *
 * See goa_object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
goa_object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (GOA_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
}

/**
 * goa_object_manager_client_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to goa_object_manager_client_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with goa_object_manager_client_new_for_bus().
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * goa_object_manager_client_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (nullable): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like goa_object_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See goa_object_manager_client_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type GoaObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
goa_object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (GOA_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", goa_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


